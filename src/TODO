- figure out how to deal with nonlinear patterns
  currently we enforce linearity: can't use a variable multiple times in same pattern
  (except for or-patterns, each branch of which must use exactly same variables)

  other options:
  - nonlinearity results in equality tests (what racket does)
  - nonlinearity shadows, left-to-right, and we handle this in translation to
    racket.

- think about how equality patterns, nonlinearity, and variable binding
  interact.

  we'd like it to be possible *both* to depend on equality of variables bound in
  *same* pattern, AND to allow to check for equality with arbitrary expressions,
  incl. variables bound elsewhere.

  questions:
  - what does pattern (cons x x) do?
  - what does pattern (cons x (= x)) do?
  - what will pattern (cons (= x) x) do?
  - what if x is already bound in the environment?

  for reference, Racket's design choice:
  - patterns are nonlinear. multiple use = equality testing.
  - (== expr) pattern tests equality w/ arbitrary expressions.
  - pattern variables are not bound in expressions inside the pattern.
    so you can *only* test pattern vars for equality, not (eg) inequality.

- allow pattern let-binding (for irrefutable patterns)
  - move pat-irrefutable? into elab.rkt, since it requires type-checking.

- implement e-case-mono?

- implement antitonicity? (and e-case-anti?)

EVENTUALLY
- implement polymorphism
