- document how nonlinear patterns work. document how equality patterns work.

  nonlinear patterns: multiple uses of same variable check for equality.

  equality patterns: use when you want to check equality with something that is
  *not* a variable bound in the same pattern.

  note that variables bound in a pattern are *not* in the scope of expressions
  within that pattern. for example:

      (let [(x = 0)] (case foo [(cons x (= x)) x]))

  the (cons x (= x)) will match only if foo is of the form (cons _ 0), and will
  bind x to the first argument of the cons.

- add type definitions to language

- add some type constructors & intro & elim forms for them
  - flat lattices, (Flat A) = bottom <= .... A ... <= top
  - lexical sums (A <+ B)? lexical products (A <* B)?
  - tensor products of semilats?

- allow pattern let-binding (for irrefutable patterns)
  - move pat-irrefutable? into elab.rkt, since it requires type-checking.

- add tonicity to e-case? problem here is that some things we *can't*
  case-examine {mono,anti}tonically, for example, bools.

EVENTUALLY
- implement polymorphism
