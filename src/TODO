- put patterns in more places!
  - make pattern-match failure in a for loop exclude the item?

- implement irrefutable-pattern? & use it appropriately
  - needed for using patterns to destructure monotone values in case-expressions

- implement set-comprehensions
  - to implement where-clauses, we'll probably want that boolean eliminator

- implement some sort of monotone eliminator for booleans. options:
  - make booleans *literally* sets of units, add syntax sugar to taste.
  - add eliminator which imitates set-of-units encoding.
    this is conceptually more complicated, but is probably less work!
  - make e-join-in understand booleans?
  - augment "for" to natively understand iterating over booleans!
    the elim form is then (for ([#:when foo]) WHATEVER)

- implement e-case-mono?
- implement antitonicity? (e-case-anti?)

EVENTUALLY
- implement polymorphism
