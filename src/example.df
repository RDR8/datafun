;; -*- scheme-mode -*-
(two : nat)
(two = 2)


;; subtyping tests
(add3 : nat -> nat)
(add3 = (+ 3))

(somefns : (set (nat -> nat)))
(somefns = (set (+ 3) (- 4) (fn x x)))

;; this should be type-inferrable
(mapfns1 = (map ["add3" (+ 3)] ["minus4" (- 4)]))
(mapfns2 : (map str (nat -> nat)))
(mapfns2 = mapfns1)
(mapfns3 : (map str (nat -> nat)))
(mapfns3 = (join mapfns1 (map ["zero" (fn x 0)])))


;; negation.
(not : bool ->- bool)
(not x = (unless x #t))

;; any two of `not', `when', and `unless' would let us derive the third
;; (although polymorphism might be an issue for typechecking it).
;; for example:
(unless-bool : bool ->- bool ~> bool)
(unless-bool c X = (when (not c) X))

;; disjunction, eagerly
;; this is easy because disjunction *is* the join operator on bools.
(or : bool bool ~> bool)
(or x y = (join x y))

;; conjunction, eagerly
(and : bool bool ~> bool)
(and x y = (when x y))


;; now that we have antitone negation, we can write < properly!
(< : nat ->- nat ~> bool)
(< x y = (not (<= y x)))

;; previously, we used this hack:
;; (< x y = (<= (+ x 1) y))


;; representing booleans as sets of units
(triv : (*))
(triv = (cons))

(tt ff : (set (*)))
(tt = (set triv))
(ff = (set))

(conj : (set (*)) (set (*)) ~> (set (*)))
(conj X Y = (for ([_ X] [_ Y]) tt))

;; Neel calls this "guard"
(bool->set : bool ~> (set (*)))
(bool->set x = (when x tt))

(set->bool : (set (*)) ~> bool)
(set->bool x = (for ([_ x]) #t))

;; kind of a hack.
(negate : (set (*)) ->- (set (*)))
(negate X = (unless (set->bool X) (set (cons))))


;; operations on sets of naturals
(member : nat -> (set nat) ~> bool)
(member a X = (for ([x X]) (= a x)))

(setminus : (set nat) ~> (set nat) ->- (set nat))
(setminus X Y = (for/set ([x X] #:unless (member x Y))
                  x))


;; ancestors example
(person = (set "constable" "harper" "arbob"
               "aldrich" "reynolds" "neel" "rntz"))

(advisor = (set (cons "constable" "harper")
                (cons "harper" "arbob")
                (cons "reynolds" "neel")
                (cons "aldrich" "neel")
                (cons "neel" "rntz")))

(ancestor : (set (* str str)))
(ancestor = (fix ancestor
                 (join
                  ;; (for ([p person]) (set (cons p p)))
                  advisor
                  (for/set ([(cons a b) advisor]
                            [(cons (= b) c) ancestor])
                    (cons a c)))))
