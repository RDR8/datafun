;; -*- mode: scheme -*-
(two : nat)
(two = 2)


;; subtyping tests
(add3 : nat -> nat)
(add3 = (+ 3))

(somefns : (set (nat -> nat)))
(somefns = (set (+ 3) (- 4) (fn x x)))

;; this should be type-inferrable
(mapfns1 = (map ["add3" (+ 3)] ["minus4" (- 4)]))
(mapfns2 : (map str (nat -> nat)))
(mapfns2 = mapfns1)
(mapfns3 : (map str (nat -> nat)))
(mapfns3 = (lub mapfns1 (map ["zero" (fn x 0)])))


;; negation.
(not : bool ->- bool)
(not x = (unless x #t))

;; any two of `not', `when', and `unless' would let us derive the third
;; (although polymorphism might be an issue for typechecking it).
;; for example:
(unless-bool : bool ->- bool ~> bool)
(unless-bool c X = (when (not c) X))

;; disjunction, eagerly
;; this is easy because disjunction *is* the lub operator on bools.
(or : bool bool ~> bool)
(or x y = (lub x y))

;; conjunction, eagerly
(and : bool bool ~> bool)
(and x y = (when x y))


;; now that we have antitone negation, we can write < properly!
(< : nat ->- nat ~> bool)
(< x y = (not (<= y x)))

;; previously, we used this hack:
;; (< x y = (<= (+ x 1) y))


;; representing booleans as sets of units
(triv : (*))
(triv = (cons))

(tt ff : (set (*)))
(tt = (set triv))
(ff = (set))

(conj : (set (*)) (set (*)) ~> (set (*)))
(conj X Y = (tt for _ in X
                for _ in Y))

;; Neel calls this "guard"
(bool->set : bool ~> (set (*)))
(bool->set x = (when x tt))

(set->bool : (set (*)) ~> bool)
(set->bool x = (#t for _ in x))

;; kind of a hack.
(negate : (set (*)) ->- (set (*)))
(negate X = (unless (set->bool X) tt))


;; operations on sets of naturals
(nat-member : nat -> (set nat) ~> bool)
(nat-member a X = ((= a x) for x in X))

(str-member : str -> (set str) ~> bool)
(str-member a X = ((= a x) for x in X))

(setminus : (set nat) ~> (set nat) ->- (set nat))
(setminus X Y = (set x
                 for x in X
                 unless (nat-member x Y)))

;; set comprehensions
(some-nats : (set nat))
(some-nats = (set x (+ 10 x)
              for x in (set 1 2 3)))

(powers-upto : nat -> nat ~> (set nat))
(powers-upto b n =
  (fix P (set 1)
         (set (* b x)
          for x in P
          when (<= (* b x) n))))


;; ancestors example
(person = (set "constable" "harper" "arbob"
               "aldrich" "reynolds" "neel" "rntz"))

(advisor = (set (cons "constable" "harper")
                (cons "harper" "arbob")
                (cons "reynolds" "neel")
                (cons "aldrich" "neel")
                (cons "neel" "rntz")))

(ancestor : (rel str str))
(fix ancestor = (lub advisor recur)
     where (mono recur = (set (cons a c)
                          for (cons a b) in advisor
                          for (cons (= b) c) in ancestor)))


;; relation composition
(compose : (rel str str) (rel str str) ~> (rel str str))
(compose X Y = (set (cons a c)
                for (cons a b) in X
                for (cons (= b) c) in Y))

;; reflexivity
(refl : (set str) ~> (rel str str))
(refl X = (set (cons x x) for x in X))

;; making a relation symmetric
(symm : (rel str str) ~> (rel str str))
(symm X = (set (cons a b) (cons b a)
               for (cons a b) in X))

;; transitive closure, more generically
(transitive-closure : (rel str str) ~> (rel str str))
(transitive-closure R = (fix T R (compose R T)))

(ancestor-2 = (transitive-closure advisor))

;; reflexive transitive closure
(dag->preorder : (set str) (rel str str) ~> (rel str str))
(dag->preorder V E = (fix self (refl V) (compose self E)))

(ancestor-3 = (dag->preorder person advisor))

;; reachability
(reachable : (rel str str) ~> str str -> bool)
(reachable R a b = (#t for (cons (= a) (= b)) in (dag->preorder domain R))
  where (mono domain = (set x for (cons x _) in R)))

(ancestor? : str str -> bool)
(ancestor? = (reachable ancestor))

;; reachability, again
(reachable-from : (rel str str) ~> str -> (set str))
(reachable-from R start = (fix S
    (set start)
    (set b for (cons a b) in R
           when (str-member a S))))


;; the WHILE language & static analysis
(type label = nat)
(type var = str)

(type bool-op  = (+ eq le))
(type arith-op = (+ add sub mul div))
(type imm      = (+ (var var) (num nat)))
(type expr     = (+ (imm imm)
                    (arith arith-op imm imm)
                    (test bool-op imm imm)))
(type stmt     = (+ skip
                    (assn var expr)
                    (if expr label label)))

;; some basic helper functions
(imm-vars : imm -> (set var))
(imm-vars i = (case i [('var x) (set x)] [_ (set)]))

(expr-vars : expr -> (set var))
(expr-vars e = (case e
                 [('imm i) (imm-vars i)]
                 [(or ('arith _ a b) ('test _ a b))
                  (union (imm-vars a) (imm-vars b))]))

(stmt-uses : stmt -> (set var))
(stmt-uses s = (case s
                 [('assn _ e) (expr-vars e)]
                 [_ (set)]))

(stmt-defines : stmt -> (set var))
(stmt-defines s = (case s
                    [('assn x _) (set x)]
                    [_ (set)]))

;; code flow
(type code = (map label stmt))
(type flow = (rel label label))

(code->set : code -> (rel label stmt))
(code->set C = (set (cons i s)
                    for i in (keys C)
                    for s in (case (lookup C i)
                               [('just x) (set x)]
                               ['none (as (set stmt) (set))])))

(flow : code -> flow)
(flow C = (union
           ;; if-statements branch
           ((set (cons i j) (cons i k))
            for (cons i ('if _ j k)) in (code->set C))
           ;; otherwise, execution continues in a straight line
           ((set (cons i (+ i 1)))
            for (cons i (or 'skip ('assn _ _))) in (code->set C)
            for (= (+ i 1)) in (keys C))))

;; reaching definitions analysis
(rd : code flow -> (rel label label var))
(rd code flow =
    (fix RD
     (set (cons i i v)
        for (cons i s) in (code->set code)
        for v in (stmt-defines s))
     (set (cons j l v)
        for (cons j s) in (code->set code)
        ;; for any statement that flows to us
        for (cons i (= j)) in flow
        ;; we inherit its defined variables
        for (cons i l v) in RD
        ;; unless we redefine them
        unless (#t for (= v) in (stmt-defines s)))))

;;(rd-3 : code flow -> (map label (map var label)))
;; TODO: rd-3

;; ;; live variable analysis
;; (live : code flow -> (set (* label var)))
