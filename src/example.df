(x : nat)
(x = 2)

;; negation.
(not : bool ->- bool)
(not x = (unless x #t))

;; any two of `not', `when', and `unless' would let us derive the third
;; (although polymorphism might be an issue for typechecking it).
;; for example:
(unless-bool : bool ->- bool ~> bool)
(unless-bool c X = (when (not c) X))

;; disjunction, eagerly
;; this is easy because disjunction *is* the join operator on bools.
(or : bool bool ~> bool)
(or x y = (join x y))

;; conjunction, eagerly
(and : bool bool ~> bool)
(and x y = (when x y))


;; now that we have antitone negation, we can write < properly!
(< : nat ->- nat ~> bool)
(< x y = (not (<= y x)))

;; previously, we used this hack:
;; (< x y = (<= (+ x 1) y))


;; representing booleans as sets of units
(triv : (*))
(triv = (cons))

(tt ff : (set (*)))
(tt = (set triv))
(ff = (set))

(conj : (set (*)) (set (*)) ~> (set (*)))
(conj X Y = (for ([_ X] [_ Y]) tt))

;; Neel calls this "guard"
(bool->set : bool ~> (set (*)))
(bool->set x = (when x tt))

(set->bool : (set (*)) ~> bool)
(set->bool x = (for ([_ x]) #t))

;; kind of a hack.
(negate : (set (*)) ->- (set (*)))
(negate X = (unless (set->bool X) (set (cons))))


;; operations on sets of naturals
(member : nat -> (set nat) ~> bool)
(member a X = (for ([x X]) (= a x)))

(setminus : (set nat) ~> (set nat) ->- (set nat))
(setminus X Y = (for/set ([x X] #:unless (member x Y))
                  x))


;; ancestors example
(person = (set "constable" "harper" "arbob"
               "aldrich" "reynolds" "neel" "rntz"))

(advisor = (set (cons "constable" "harper")
                (cons "harper" "arbob")
                (cons "reynolds" "neel")
                (cons "aldrich" "neel")
                (cons "neel" "rntz")))

(ancestor : (set (* str str)))
(ancestor = (fix ancestor
                 (join
                  ;; (for ([p person]) (set (cons p p)))
                  advisor
                  (for/set ([(cons a b) advisor]
                            [(cons (= b) c) ancestor])
                    (cons a c)))))
