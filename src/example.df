;; -*- mode: scheme -*-
(two : nat)
(two = 2)


;; subtyping tests
(add3 : nat -> nat)
(add3 = (+ 3))

(somefns : (set (nat -> nat)))
(somefns = (set (+ 3) (- 4) (fn x x)))

;; this should be type-inferrable
(mapfns1 = (map ["add3" (+ 3)] ["minus4" (- 4)]))
(mapfns2 : (map str (nat -> nat)))
(mapfns2 = mapfns1)
(mapfns3 : (map str (nat -> nat)))
(mapfns3 = (lub mapfns1 (map ["zero" (fn x 0)])))


;; negation.
(not : bool ->- bool)
(not x = (unless x #t))

;; any two of `not', `when', and `unless' would let us derive the third
;; (although polymorphism might be an issue for typechecking it).
;; for example:
(unless-bool : bool ->- bool ~> bool)
(unless-bool c X = (when (not c) X))

;; disjunction, eagerly
;; this is easy because disjunction *is* the lub operator on bools.
(or : bool bool ~> bool)
(or x y = (lub x y))

;; conjunction, eagerly
(and : bool bool ~> bool)
(and x y = (when x y))


;; now that we have antitone negation, we can write < properly!
(< : nat ->- nat ~> bool)
(< x y = (not (<= y x)))

;; previously, we used this hack:
;; (< x y = (<= (+ x 1) y))


;; representing booleans as sets of units
(triv : (*))
(triv = (cons))

(tt ff : (set (*)))
(tt = (set triv))
(ff = (set))

(conj : (set (*)) (set (*)) ~> (set (*)))
(conj X Y = (tt for _ <- X
                for _ <- Y))

;; Neel calls this "guard"
(bool->set : bool ~> (set (*)))
(bool->set x = (when x tt))

(set->bool : (set (*)) ~> bool)
(set->bool x = (#t for _ <- x))

;; kind of a hack.
(negate : (set (*)) ->- (set (*)))
(negate X = (unless (set->bool X) tt))


;; operations on sets of naturals
(member : nat -> (set nat) ~> bool)
(member a X = ((= a x) for x <- X))

(setminus : (set nat) ~> (set nat) ->- (set nat))
(setminus X Y = (set x
                 for x <- X
                 unless (member x Y)))

;; set comprehensions
(some-nats : (set nat))
(some-nats = (set x (+ 10 x)
              for x <- (set 1 2 3)))

(powers-upto : nat -> nat ~> (set nat))
(powers-upto b n =
  (fix P (set 1)
         (set (* b x)
          for x <- P
          when (<= (* b x) n))))


;; ancestors example
(person = (set "constable" "harper" "arbob"
               "aldrich" "reynolds" "neel" "rntz"))

(advisor = (set (cons "constable" "harper")
                (cons "harper" "arbob")
                (cons "reynolds" "neel")
                (cons "aldrich" "neel")
                (cons "neel" "rntz")))

(ancestor : (set (* str str)))
(fix ancestor = (lub advisor recur)
     where (mono recur = (set (cons a c)
                          for (cons a b) <- advisor
                          for (cons (= b) c) <- ancestor)))


;; relation composition
(compose : (set (* str str)) (set (* str str)) ~> (set (* str str)))
(compose X Y = (set (cons a c)
                for (cons a b) <- X
                for (cons (= b) c) <- Y))

;; reflexivity
(refl : (set str) ~> (set (* str str)))
(refl X = (set (cons x x) for x <- X))

;; transitive closure, more generically
(transitive-closure : (set (* str str)) ~> (set (* str str)))
(transitive-closure R = (fix T R (compose R T)))

(ancestor-2 = (transitive-closure advisor))

;; reflexive transitive closure
(to-poset : (set str) (set (* str str)) ~> (set (* str str)))
(to-poset domain R = (fix self (refl domain) (compose self R)))

(ancestor-3 = (to-poset person advisor))
