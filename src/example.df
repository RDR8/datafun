(x : nat)
(x = 2)

(john : (record [name str]))
(john = (record [name "hello"]))

;; negation
(not : (bool -> bool))
(not x = (case x [#t #f] [#f #t]))

;; disjunction, eagerly
;; this is easy because disjunction *is* the join operator on bools.
(or : (bool bool ~> bool))
(or x y = (join x y))

;; conjunction, eagerly
;; XXX: how can we write this?
(and : (bool bool ~> bool))
(and x y = (trustme (case x [#t y] [#f #f])))

;; XXX: how do we write this function?
;; note that (record) is 1.
(bool->set : (bool ~> (set (record))))
(bool->set x = (trustme (case x [#t (set (record))]
                                [#f (set)])))

(set->bool : ((set (record)) ~> bool))
(set->bool x = (let _ <- x in #t))

;; XXX: how can we write this?
(< : (nat -> nat ~> bool))
;; this works but is a hack, not extensible to other types:
(< x y = (<= (+ x 1) y))

;; this does not work, 'not is not monotone, can't see 'y:
;; (< x y = (not (<= y x)))
;; this *could* work, perhaps, if we accounted for antitonicity and made
;; negation and <= appropriately antitone - but then I don't know how we'd
;; write 'not!

;; one problem is the lack of a good eliminator for bool.
;; bool is an *ordered* sum, (1 <| 1)
;; but can also be thought of as (FS 1). does that help us?
;; yes! it lets us write conjunction:
;; conj : FS 1 ~> FS 1 ~> FS 1
;; conj x y = {1 | a in x, b in y}
;;          = let a <- x in let b <- y in {1}
(conj : ((set (record)) (set (record)) ~> (set (record))))
(conj x y = (let a <- x in
             (let b <- y in (set (record)))))

;; however, I *still* don't see how to write <:
;; (< : (nat -> nat ~> (set (record))))
;; (< m n = ???)


;; ancestors example
(person = (set "constable" "harper" "arbob"
               "aldrich" "reynolds" "neel" "rntz"))

(parent = (set (cons "constable" "harper")
               (cons "harper" "arbob")
               (cons "reynolds" "neel")
               (cons "aldrich" "neel")
               (cons "neel" "rntz")))

;; (ancestor = (fix ancestor
;;                  (join
;;                   (let p <- person in (cons p p))
;;                   (let p <- parent in
;;                        (let a <- ancestor in
;;                             (if (equal? )))))))
