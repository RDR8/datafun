(x : nat)
(x = 2)

;; negation
(not : bool -> bool)
(not x = (case x [#t #f] [#f #t]))

;; disjunction, eagerly
;; this is easy because disjunction *is* the join operator on bools.
(or : bool bool ~> bool)
(or x y = (join x y))

;; conjunction, eagerly
(and : bool bool ~> bool)
(and x y = (when x y))


;; XXX: how can we write this?
(< : nat -> nat ~> bool)
;; this works but is a hack, not extensible to other types:
(< x y = (<= (+ x 1) y))

;; this does not work, 'not is not monotone, can't see 'y:
;; (< x y = (not (<= y x)))
;; this *could* work, perhaps, if we accounted for antitonicity and made
;; negation and <= appropriately antitone - but then I don't know how we'd
;; write 'not!


;; representing booleans as sets of units
(triv : (*))
(triv = (cons))

(tt ff : (set (*)))
(tt = (set triv))
(ff = (set))

(conj : (set (*)) (set (*)) ~> (set (*)))
(conj X Y = (for ([_ X] [_ Y]) tt))

;; Neel calls this "guard"
(bool->set : bool ~> (set (*)))
(bool->set x = (when x tt))

(set->bool : (set (*)) ~> bool)
(set->bool x = (for ([_ x]) #t))


;; ancestors example
(person = (set "constable" "harper" "arbob"
               "aldrich" "reynolds" "neel" "rntz"))

(advisor = (set (cons "constable" "harper")
                (cons "harper" "arbob")
                (cons "reynolds" "neel")
                (cons "aldrich" "neel")
                (cons "neel" "rntz")))

(ancestor : (set (* str str)))
(ancestor = (fix ancestor
                 (join
                  ;; (for ([p person]) (set (cons p p)))
                  advisor
                  (for/set ([(cons a b1) advisor]
                            [(cons b2 c) ancestor]
                            #:when (= b1 b2))
                    (cons a c)))))
