(x : nat)
(x = 2)

;; negation
(not : bool -> bool)
(not x = (case x [#t #f] [#f #t]))

;; disjunction, eagerly
;; this is easy because disjunction *is* the join operator on bools.
(or : bool bool ~> bool)
(or x y = (join x y))

;; conjunction, eagerly
;; XXX: how can we write this?
(and : bool bool ~> bool)
(and x y = (trustme (case x [#t y] [#f #f])))


;; XXX: how can we write this?
(< : nat -> nat ~> bool)
;; this works but is a hack, not extensible to other types:
(< x y = (<= (+ x 1) y))

;; this does not work, 'not is not monotone, can't see 'y:
;; (< x y = (not (<= y x)))
;; this *could* work, perhaps, if we accounted for antitonicity and made
;; negation and <= appropriately antitone - but then I don't know how we'd
;; write 'not!

;; one problem is the lack of a good eliminator for bool.
;; bool is an *ordered* sum, (1 <| 1)
;; but can also be thought of as (FS 1). does that help us?
;; yes! it lets us write conjunction (see conj, below)


;; representing booleans as sets of units
(triv : (record))
(triv = (record))

(tt ff : (set (record)))
(tt = (set triv))
(ff = (set))

(conj : (set (record)) (set (record)) ~> (set (record)))
(conj X Y = (for ([a X] [b Y]) (set (record))))

;; however, I *still* don't see how to write <:
;; (< : (nat -> nat ~> (set (record))))
;; (< m n = ???)

;; XXX: how do we write this function?
;; note that (record) is 1.
(bool->set : bool ~> (set (record)))
(bool->set x = (trustme (case x [#t tt] [#f ff])))

(set->bool : (set (record)) ~> bool)
(set->bool x = (for ([_ x]) #t))


;; ancestors example
(person = (set "constable" "harper" "arbob"
               "aldrich" "reynolds" "neel" "rntz"))

(parent = (set (cons "constable" "harper")
               (cons "harper" "arbob")
               (cons "reynolds" "neel")
               (cons "aldrich" "neel")
               (cons "neel" "rntz")))

(ancestor : (set (* str str)))
(ancestor = (fix ancestor
                 (join
                  ;; (for ([x person]) (set (cons x x)))
                  parent
                  (for ([p parent]
                        [a ancestor])
                    (case (= (proj 1 p) (proj 0 a))
                      [#t (set (cons (proj 0 p) (proj 1 a)))]
                      [#f (set)])))))
