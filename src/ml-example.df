(* -*- mode: sml -*- *)

val two : nat
val two = 2

val add3 : nat -> nat
fun add3 x = x + 3

val somefns : {nat -> nat}
val somefns = {add3, (-) 4, (fn x => x)}

val not : bool ->- bool
fun not x = unless x then true

val or : bool ~> bool ~> bool
fun or x y = x lub y

val and : bool ~> bool ~> bool
fun and x y = when x then y

(* now that we have antitone negation, we can write < properly! *)
val (<) : nat ->- nat ~> bool
fun (x < y) = not (y <= x)

(* NB: this (incorrect) implementation of < gives an UTTERLY useless error
 * message about tonicities mono & anti having no lub:
 *
 * fun (x < y) = not (x <= y)
 *
 * TODO: fix this error message.
 *)


(* representing booleans as sets of units *)
val tt, ff : {()}
val tt = {()}
val ff = {}

val conj : {()} ~> {()} ~> {()}
fun conj x y = ⋁(_ ∈ x, _ ∈ y) tt
(* alternative implementations: *)
(* fun conj x y = (tt | _ ∈ x, _ ∈ y) *)
(* fun conj x y = {() | _ ∈ x, _ ∈ y} *)

(* Neel calls this "guard" *)
val bool2set : bool ~> {()}
fun bool2set x = when x then tt

val set2bool : {()} ~> bool
fun set2bool x = () in? x
(* fun set2bool x = ⋁(_ in x) true *) (* alternative *)

(* kind of a hack *)
val negate : {()} ->- {()}
fun negate x = unless set2bool x then tt


(* operations on sets of naturals & strings *)
val nat_member : nat -> set nat ~> bool
fun nat_member a s = (a = x | x in s)

(* or, using equality patterns *)
val str_member : str -> set str ~> bool
fun str_member a s = (true | =a in s)

val nat_setminus : set nat ~> set nat ->- set nat
fun nat_setminus a b = {x | x in a, not (nat_member x b)}

(* set comprehension demos *)
val some_nats : set nat
val some_nats = ⋁(x ∈ {1,2,3}) {x, x + 10}

val powers_upto : nat -> nat ~> set nat
fun powers_upto b n = fix s = {1} ∨ {b*x | x in s, (b*x) <= n}

(* map & filter *)
val nat_map : (nat -> nat) -> {nat} ~> {nat}
fun nat_map f a = {f x | x ∈ a}

val nat_filter : (nat -> bool) ~> {nat} ~> {nat}
fun nat_filter p a = {x | x ∈ a, p x}

(* can also be invoked with primitive `cross' / (**) / (×) *)
val nat_cross : {nat} ~> {nat} ~> {nat * nat}
fun nat_cross a b = {(x,y) | x ∈ a, y ∈ b}


(* some things I originally thought datafun couldn't do, but it can! *)
val nat_subsets : {nat} ~> {{nat}}
fun nat_subsets n =
  fix s = {{}}
        ∨ {{x} | x in n}
        ∨ {x ∨ y | x in s, y in s}

(* upto n = {x | x <= n}; includes upper bound
 * below n = {x | x < n}; excludes upper bound
 *)
val upto, below : nat ~> {nat}
fun upto n = fix s = {0} ∨ {x+1 | x in s, x < n}
fun below n = {x | x ∈ upto n, x < n}

(* range i j = {x | i <= x <= j}; inclusive. *)
val range : nat ->- nat ~> {nat}
fun range i j = nat_setminus (upto j) (below i)


(* ancestors *)
val person = { "constable", "harper", "arbob", "aldrich", "reynolds", "neel"
             , "rntz" }

val advisor = { ("constable", "harper"), ("harper", "arbob")
              , ("reynolds", "neel"), ("aldrich", "neel"), ("neel", "rntz") }

val ancestor : {str, str}
(* fix ancestor = advisor ∨ {(a,c) | (a,b) ∈ advisor, (=b,c) ∈ ancestor} *)
fix ancestor = advisor ∨ (ancestor • ancestor)

(* relation composition. can also use primitive operator (•) / `compose'. *)
val str_compose : {str, str} ~> {str, str} ~> {str, str}
fun str_compose x y = {(a,c) | (a,b) in x, (=b,c) in y}


(* CYK parsing! *)
type sym = str
type rule = String(str) | Cat(sym, sym)
type grammar = {sym * rule}

(* (a,i,j) represents that symbol a produces the substring w[i..j] *)
type item = sym * nat * nat

val parse : str -> grammar ~> {sym}
fun parse w g =
  let val len = strlen w
      mono state : set item
      fix state = {(a,i,k) | (a, Cat(b,c)) ∈ g
                           , (=b,i,j) ∈ state, (=c,=j,k) ∈ state}
                ∨ (⋁((a, String(s)) ∈ g)
                   let val n = strlen s
                   in {(a,i,i+n) | i ∈ range 0 (len-n), s = substr w i (i+n)})
  in {a | (a,0,=len) ∈ state}

(* a grammar to test on *)
val gram_hello = { ("Start", Cat("H", "W"))
                 , ("H", String("hello"))
                 , ("W", String("world")) }

val test_string = "helloworld"


(* the WHILE language & static analysis *)
type label = nat
type var = str

type bool_op = EQ | LE
type arith_op = ADD | SUB | MUL | DIV
type imm = Var(var) | Num(nat)
type expr = Imm(imm) | Arith(arith_op, imm, imm) | Test(bool_op, imm, imm)
type stmt = Skip | Assign(var, expr) | If(expr, label, label)
type code = {label: stmt}

(* a trivial example WHILE program *)
val prog1 : code
val prog1 = { 0: Assign("a", Imm(Num(2)))
            , 1: Assign("b", Imm(Var("a")))
            }

(* basic properties *)
val imm_vars : imm -> {var}
val expr_vars : expr -> {var}
val uses : stmt -> {var}
val defines : stmt -> {var}
fun imm_vars i = case i | Var(v) => {v} | Num(_) => {}
fun expr_vars e =
  case e | Imm(i) => imm_vars i
         | Arith(_, a, b) | Test(_, a, b) => imm_vars a ∨ imm_vars b
fun uses s = case s | Assign(_,e) | If(e,_,_) => expr_vars e | _ => {}
fun defines s = case s | Assign(v,_) => {v} | _ => {}

(* code flow *)
type flow = {label, label}

val flow : code -> flow
fun flow code = ⋁((i,s) ∈ entries code)
                case s | If(_,j,k) => {(i,j), (i,k)}
                       | _ => {(i,i+1) | i+1 ∈? keys code}

(* live variable analysis
 *
 * PROBLEM: really, I need an exit label & what vars are live there.
 *)
val live : code -> flow -> {label, var}
fun live code flow =
  fix self = ⋁((i,s) ∈ entries code)
              {(i,v) | v ∈ uses s}
              ∨ {(i,v) | (=i,j) ∈ flow, (=j,v) ∈ self, not (v ∈? defines s)}

(* reaching definitions analysis
 * produces a set of tuples (i, l, v)
 * meaning: the assignment to `v' at label `l' may reach label `i'
 *
 * hm. in this versoin, a label can see its own variable definitions!
 *)
val rd : code -> flow -> {label, label, var}
fun rd code flow =
  fix self = ⋁((i,s) ∈ entries code)
              {(i, i, v) | v ∈ defines s}
              ∨ {(i, l, v) | (j, =i) ∈ flow, (=j, l, v) ∈ self
                           , not (v ∈? defines s)}

(* possible value analysis *)
(* type values = {label * var: flat nat} *)
