(* -*- mode: sml -*- *)

val two : nat
val two = 2

val add3 : nat -> nat
fun add3 x = x + 3

val somefns : {nat -> nat}
val somefns = {add3, (-) 4, (fn x => x)}

val not : bool ->- bool
fun not x = unless x then true

val or : bool ~> bool ~> bool
fun or x y = x lub y

val and : bool ~> bool ~> bool
fun and x y = when x then y

(* now that we have antitone negation, we can write < properly! *)
val (<) : nat ->- nat ~> bool
fun (x < y) = not (y <= x)

(* NB: this (incorrect) implementation of < gives an UTTERLY useless error
 * message about tonicities mono & anti having no lub:
 *
 * fun (x < y) = not (x <= y)
 *)


(* representing booleans as sets of units *)
val tt, ff : {()}
val tt = {()}
val ff = {}

val conj : {()} ~> {()} ~> {()}
fun conj x y = ⋁(_ ∈ x, _ ∈ y) tt
(* fun conj x y = (tt | _ ∈ x, _ ∈ y) *)
(* fun conj x y = {() | _ ∈ x, _ ∈ y} *)

(* neel calls this "guard" *)
val bool2set : bool ~> {()}
fun bool2set x = when x then tt

val set2bool : {()} ~> bool
fun set2bool x = () in? x
(* fun set2bool x = ⋁(_ in x) true *) (* alternative *)

(* kind of a hack *)
val negate : {()} ->- {()}
fun negate x = unless set2bool x then tt


(* operations on sets of naturals *)
val nat_member : nat -> set nat ~> bool
fun nat_member a s = (a = x | x in s)

(* or, using equality patterns *)
val str_member : str -> set str ~> bool
fun str_member a s = (true | =a in s)

val nat_setminus : set nat ~> set nat ->- set nat
fun nat_setminus a b = {x | x in a, not (nat_member x b)}

(* set comprehension demos *)
val some_nats : set nat
val some_nats = ⋁(x ∈ {1,2,3}) {x, x + 10}

val powers_upto : nat -> nat ~> set nat
fun powers_upto b n = fix s = {1} ∨ {b*x | x in s, (b*x) <= n}


(* some things I originally thought datafun couldn't do, but it can! *)
val nat_subsets : {nat} ~> {{nat}}
fun nat_subsets n =
  fix s = {{}}
        ∨ {{x} | x in n}
        ∨ {x ∨ y | x in s, y in s}

(* upto n = {x | x <= n}; includes upper bound
 * below n = {x | x < n}; excludes upper bound
 *)
val upto, below : nat ~> {nat}
fun upto n = fix s = {0} ∨ {x+1 | x in s, x < n}
fun below n = {x | x ∈ upto n, x < n}

(* range i j = {x | i <= x <= j}; inclusive. *)
val range : nat ->- nat ~> {nat}
fun range i j = nat_setminus (upto j) (below i)


(* ancestors *)
val person = { "constable", "harper", "arbob", "aldrich", "reynolds", "neel"
             , "rntz" }

val advisor = { ("constable", "harper"), ("harper", "arbob")
              , ("reynolds", "neel"), ("aldrich", "neel"), ("neel", "rntz") }

val ancestor : {str, str}
fix ancestor = advisor ∨ {(a,c) | (a,b) ∈ advisor, (=b,c) ∈ ancestor}


(* CYK parsing! *)
type sym = str
type rule = String(str) | Cat(sym, sym)
type grammar = {sym, rule}

(* (a,i,j) represents that symbol a produces the substring w[i..j] *)
type item = sym * nat * nat

val parse : str -> grammar ~> {sym}
fun parse w g =
  let val len = strlen w
      mono val state : set item
      fix state = {(a,i,k) | (a, Cat(b,c)) ∈ g
                           , (=b,i,j) ∈ state, (=c,=j,k) ∈ state}
                ∨ (⋁((a, String(s)) ∈ g)
                   let val n = strlen s
                   in {(a,i,i+n) | i ∈ range 0 (len-n), s = substr w i (i+n)})
  in {a | (a,0,=len) ∈ state}

(* a grammar to test on *)
val gram_hello = { ("Start", Cat("H", "W"))
                 , ("H", String("hello"))
                 , ("W", String("world")) }

val test_string = "helloworld"
