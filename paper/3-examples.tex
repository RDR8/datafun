%% FIGURE: SYNTAX SUGAR
\begin{figure}
  \[\begin{array}{lccl}
  %% expressions
  \textsf{terms} &
  e &\bnfeq& ... \pipe e \isin e \pipe \setfor{e}{\mc{L}}
             \pipe \forin{\mc{L}}{e}\\
  &&& \mathcal{C}[\;e]^* \pipe \rawcase{e}{[{p} \cto {e}]^*}
  \vspace{0.5em}\\
  %% patterns
  %%
  %% TODO: maybe remove the pattern-matching stuff? since we don't explain how
  %% to translate it & we also use various other sugar we don't explain how to
  %% translate, why do we include only pattern-matching here?
  \textsf{patterns} &
  p &\bnfeq& \pwild \pipe x \pipe (p,p)
             \pipe \ms{true} \pipe \ms{false} \pipe \mathcal{C}[\;p]^*
  \vspace{0.5em}\\
  \textsf{constructors} & \mathcal{C} && \text{are abstract identifiers}
  \vspace{0.5em}\\
  %% loop clauses
  \textsf{loops} &
  \mc{L} &\bnfeq& \mc{L}, \mc{L} \pipe p \in e \pipe e
  \end{array}\]

  %% the desugaring syntax-expansion itself
  \begin{eqnarray*}
    %% e_1 \isin e_2            &\expandsto& \forin{x \in e_2} e_1 = x\\
    \setfor{e}{\mc{L}}       &\expandsto& \forin{\mc{L}}{\{e\}}\\
    \forin{\mc{L}_1,\mc{L}_2}{e}
    &\expandsto& \forin{\mc{L}_1}{\forin{\mc{L}_2}{e}}\\
    \forin{p\in e_1}{e_2} &\expandsto&
    \letin{x}{e_1}{\rawcase{x}{p \cto e_2;\,\pwild \cto \unit}}\\
    \forin{e_1}{e_2} &\expandsto& \ifthen{e_1}{e_2}{\unit}
    %% e_1 \x e_2 &\expandsto& \setfor{(a,b)}{a \in e_1, b \in e_2}\\
    %% e_1 \bullet e_2 &\expandsto& \setfor{(a,c)}{(a,b) \in e_1, (b,c) \in e_2}
    %% \ms{let}~x = e_1 ~\ms{in}~ e_2
    %% &\expandsto& (\fn\bind{x} e_2)\; e_1\\
    %% \ms{let}~[x_i = e_i]^* ~\ms{in}~ e
    %% &\expandsto& [\ms{let}~x_i = e_i~\ms{in}]^* e\\
    %% \rawcase{e}{[p \cto e]^*} &\expandsto& \text{(omitted, see \todo{CITE})}
  \end{eqnarray*}
  \caption{Syntax sugar}
  \label{fig:sugar}
\end{figure}


\section{Examples}

For purposes of these examples, we use a simple Haskell-like syntax for
top-level type and function definitions. We also permit ourselves infix
notation, \ms{let}-binding, $n$-ary tuples, $n$-ary sum types with named
constructors, pattern-matching\todo{(CITE)}, and additional syntax sugar given
in Figure \ref{fig:sugar} \todo{(TODO: mention \& cite monadic query syntax)}.
All of these conveniences are supported (with slightly different concrete
syntax) in our implementation.

For clarity, we set the names of top-level variables in \textsf{sans-serif};
ordinary variables in $script$ or \mi{italic} (for long variable names); and
monotone variables in \m{bold}.

\todo{TODO: Explain nonlinear variable usage means equality.}

\todo{\begin{itemize}
\item composition of relations?
\item \texttt{make}-style topological sort?
\item SQL-style examples?
\item translating relational algebra into datafun?
\end{itemize}}


\subsection{Filtering, mapping, and cross products}

Although Datafun as presented does not have polymorphism, we give our examples
their most general possible type schemes. \todo{why?}

\todo{these examples are perhaps a good place to point out subtleties of
  monotonicity typing}

\[\begin{array}{l}
\fname{map} ~:~ (A \uto B) \uto \Set{A} \mto \Set{B}\\
\fname{map}\;f\;\m{A} = \setfor{f\;x}{x \in \m{A}}\\
\\
\fname{filter} ~:~ (A \uto \bool) \mto \Set{A} \mto \Set{A}\\
\fname{filter}\;\m{f}\;\m{A} = \setfor{x}{x \in \m{A}, \m{f}\; x}\\
\\
(\times) ~:~ \Set{A} \mto \Set{B} \mto \Set{A \x B}\\
\m{A} \times \m{B} = \setfor{(a,b)}{a \in \m{A}, b \in \m{B}}
\end{array}\]

\TODO


%% FIGURE: PRIMITIVES
\begin{figure}
  %% TODO: remove unused primitives.
  \[\begin{array}{cll}
  \neg &\of& \bool \uto \bool\\
  =   &\of& \eq{A} \uto \eq{A} \uto \bool\\
  \le &\of& \eq{A} \uto \eq{A} \mto \bool\\
  %% \fname{keys}     &:& \Map{A}{B} \mto \Set{A}\\
  %% \fname{entries}  &:& \Map{A}{B} \uto \Set{A \x B}\\
  %% \fname{tabulate} &:& \Set{A} \mto (A \uto B) \mto \Map{A}{B}\\
  %% \fname{getWith}  &:& \Map{\eq{A}}{B} \mto \eq{A} \uto (B \mto L) \mto L\\
  %% \fname{get}      &:& \Map{\eq{A}}{L} \mto \eq{A} \uto L\\
  %% \fname{substrings} &\of& \ms{Str} \uto \Set{\ms{Str}}\\
  %% \fname{size}     &:& \Set{\eq{A}} \mto \N\\
  \fname{range}    &:& \N \uto \N \mto \Set{\N}\\
  \fname{length}   &:& \str \uto \N\\
  \fname{substring} &:& \str \uto \N \uto \N \uto \str
  \end{array}\]
  \caption{Primitive functions and their type schemes}
  \label{fig:primitives}
\end{figure}


\subsection{Testing for membership}

\todo{Use this as example of $\bigvee$ at non-set (here, boolean) type.}

\[\begin{array}{l}
(\isin) ~:~ \eq{A} \uto \Set{\eq{A}} \mto \bool\\
x \isin \m{A} = \forin{y \in \m{A}} x = y
\end{array}\]

\todo{TODO: discuss nonlinear pattern-matching}

An equivalent definition, making use of nonlinear pattern-matching, would be:
\[\begin{array}{l}
x \isin \m{A} = \forin{x \in \m{A}} \ms{true}
\end{array}\]

\todo{Nonlinear pattern matching makes implicit the equality test and attendant
  restriction to equality types, but is often extremely convenient.}


\subsection{Composition of relations}

\todo{mention eqtypes again here? or use this to show them off instead of
  $({\isin})$?} \todo{work phrase ``higher-order'' in here somewhere?}

\noindent As an example of a function over relations, consider:
\[\begin{array}{l}
(\bullet) : \Set{A \x \eq{B}} \mto \Set{\eq{B} \x C} \mto \Set{A \x C}\\
\m{R} \bullet \m{S} = \setfor{(a,c)}{(a,b) \in \m{R}, (b,c) \in \m{S}}
\end{array}\]

\todo{TODO: mention you can extend to all relational algebra? give example?}


\subsection{Transitive closure}

Consider the following Datalog program:
\begin{verbatim}
parent(earendil, elrond).
parent(elrond, arwen).
ancestor(X, Y) :- parent(X, Y).
ancestor(X, Z) :- ancestor(X, Y), ancestor(Y, Z).
\end{verbatim}

\todo{Discuss how this works in Datalog, but not in Prolog, b/c Prolog is
  defined by operational semantics of unification while Datalog is denotational,
  least-model semantics. It also works in Datafun!}

\todo{Neel suggests using distinction b/w backward \& forward chaining here,
  rather than operational/denotational. see Logical Algorithms paper by
  McAllister \& co for phrasing?}

In Datafun, we may write this as:

\[\begin{array}{l}
\mathbf{data}~\ms{person} =
\ctor{E\"arendil} ~|~ \ctor{Elrond} ~|~ \ctor{Arwen}\\
\fname{parent},~\ms{ancestor} ~:~ \Set{\ms{person} \x \ms{person}}\\
\ms{parent} =
\{(\ctor{E\"arendil}, \ctor{Elrond}), (\ctor{Elrond}, \ctor{Arwen})\}\\
\ms{ancestor} = \fix{\m{X}} \ms{parent} \vee (\m{X} \bullet \m{X})
%% \setfor{(a,c)}{(a,b) \in \m{X}, (b,c) \in \m{X}}
\\
\end{array}\]


\subsubsection{Transitive closure with an upper bound}

If you know the type over which you are taking your transitive closure is
finite, this suffices. But the more general way to take a fixed-point is to give
an upper bound which you know the desired answer will not exceed. For this we
write $(\fixle{\m{x}}{e_\top} e)$

\todo{mention using $\str$ as example}

\todo{explain what happens when $e \ge e_\top$ --- it gets clamped}

\[\begin{array}{l}
\ms{person} ~:~ \Set{\str}\\
\ms{person} = \{\texttt{"e\"arendil"}, \texttt{"elrond"}, \texttt{"arwen"}\}\\
\ms{parent}, \ms{ancestor} ~:~ \Set{\str \x \str}\\
\ms{parent} = \{(\texttt{"e\"arendil"}, \texttt{"elrond"}),
(\texttt{"elrond"}, \texttt{"arwen"})\}\\
\ms{ancestor} = \fixle{\m{X}}{(\ms{person} \x \ms{person})}
\ms{parent} \vee (\m{X} \bullet \m{X})
%% \ms{ancestor} = \fixle{\m{X}}{%
%%   \setfor{(a,b)}{a \in \ms{person}, b \in \ms{person}}
%% }
%% \\
%% \hspace{4.87em}\ms{parent} \vee
%% \setfor{(a,c)}{(a,b) \in \m{X}, (b,c) \in \m{X}}
\end{array}\]


\subsubsection{Generic transitive closure}

For any finite eqtype $\fineq{A}$, we may write:
\[\begin{array}{l}
\ms{trans} ~:~ \Set{\fineq{A} \x \fineq{A}} \mto \Set{\fineq{A} \x \fineq{A}}
\vspace{0.3em}\\
%% \ms{trans}\ E = \fix{X} E \vee \setfor{(a,c)}{(a,b) \in E, (b,c) \in X}
%% \ms{trans}\ \m{E} = \fix{\m{X}} \m{E} \vee %
%% \setfor{(a,c)}{(a,b) \in \m{X}, (b,c) \in \m{X}}
\ms{trans}\ \m{E} = \fix{\m{X}} \m{E} \vee (\m{X} \bullet \m{X})
\end{array}\]

\noindent Similarly, for any eqtype $\eq{A}$, we may write:
\[\begin{array}{l}
\ms{trans} ~:~
\Set{\eq{A}} \mto \Set{\eq{A} \x \eq{A}} \mto \Set{\eq{A} \x \eq{A}}
\vspace{0.3em}\\
%% \ms{trans}\ \m{V}\ \m{E} = %
%% \ms{fix}~ \m{S} \le \setfor{(a,b)}{a\in \m{V}, b \in \m{V}}\\
%% \hspace{5.35em}\ms{is}~ \m{E} \vee %
%% \setfor{(a,c)}{(a,b) \in \m{S}, (b,c) \in \m{S}}\\
\ms{trans}\ \m{V}\ \m{E} = %
\fixle{\m{S}}{(\m{V} \x \m{V})} \m{E} \vee (\m{S} \bullet \m{S})
\end{array}\]

\TODO This already shows how we go beyond Datalog's .


\subsection{CYK parsing}
Parsing can be understood logically, with a parse tree representing a
proof that a certain string belongs to a language described by a
context-free grammar. As a result, it is possible to formulate parsing
in terms of proof search~\cite{deductive-parsing}. One of the
simplest algorithms for parsing context free grammars is the
Cocke-Younger-Kasami (CYK) algorithm for parsing with grammars in
Chomsky normal form.\footnote{In Chomsky normal form, each production
  is of the form $A \to B \cdot C$ or $A \to \vec{a}$, with $A,B,C$
  ranging over nonterminals, and $\vec{a}$ over nonempty strings of
  terminals.}  Given a grammar $G$, we begin by introducing a family
of predicates (sometimes called \emph{facts} or \emph{items}) $A(i,j)$,
with one $A$ for each nonterminal, and $i$ and $j$ representing
indices into a string. Given a word $w$, we write $w[i,n]$ for the
$n$-element substring of $w$ beginning at position $i$. Then, we can
specify the CYK algorithm with the following two inference rules:
\begin{mathpar}
  \inferrule*{B(i, j) \\ C(j, k) \\ (A \to B\; C) \in G}
             {A(i, k)}
  \and
  \inferrule*{ (A \to \vec{a}) \in G \\ w[i,n] = \vec{a} }
             {A(i,i+n)}
\end{mathpar}
Then, the predicate $A(i,j)$ means that $A$ is derivable from the
substring of $w$ running from $i$ to $j$, and so the whole word $w$ is
derivable from the start symbol $S$ if $S(0, \mathit{length}\;w)$ is
derivable.

In Datafun, this rule-based description of the algorithm can be
transliterated almost directly into code. We begin by introducing a
few basic types.
\[\begin{array}{l}
\mathbf{type}~\ms{sym} = \str\\
\mathbf{data}~\ms{rule} = \ctor{String}~\str ~|~ \ctor{Concat}~\ms{sym}~\ms{sym}\\
\mathbf{type}~\ms{grammar} = \Set{\ms{sym} \x \ms{rule}}\\
\mathbf{type}~\ms{fact} = \ms{sym} \x \N \x \N\\
\end{array}\]
The $\ms{sym}$ type is a type synonym representing nonterminal names
with strings.  The $\ms{rule}$ type is the type of the
right-hand-sides of productions Chomsky normal form -- either a
string, or a pair of nonterminals. A $\ms{grammar}$ is just a set of
productions -- a set of pairs of nonterminals paired with their rules.
The type $\ms{fact}$ is the type representing the atomic facts derived
by the CYK inference system -- they are triples of the rulename, the
start position, and the end position.

With these types in hand, we can write the CYK algorithm as a fixed
point computation. In fact, it is convenient to break it into two
pieces, by first defining the function whose fixed point we take. So
we can write down the $\fname{iter}$ function, which represents one step of
the fixed point iteration.
\[\begin{array}{l}
\fname{iter} ~:~ \str \uto \ms{grammar} \mto \Set{\ms{fact}} \mto \Set{\ms{fact}}\\
\fname{iter} \;\mi{text} \;\m{G} \;\m{chart} =\\
\hspace{1em}\phantom{\vee~}
\{(a,i,k) ~|~ (a, \ctor{Concat}~b~c) \in \m{G},\\
\hspace{6.25em} (b,i,j) \in \m{chart}, (c,j,k) \in \m{chart}\}\\
\hspace{1em}\vee~ \{(a,i,i+\fname{length}\;s)\\
\hspace{2.1em}|~ (a, \ctor{String}~s) \in \m{G},\\
\hspace{2.2em}\phantom{|~} i \in \fname{range}\;0\;(n-\fname{length}\;s),\\
\hspace{2.2em}\phantom{|~}
s = \fname{substring} \;\mi{text} \;i \;(i+\ms{length}\;s)\}
\end{array}\]
This function works by taking a string $\mi{text}$ and a grammar $\m{G}$, and
then taking a set of facts $\m{chart}$, and taking a union. The first clause
is a set comprehension, saying that we return $(a, i, k)$ if $(b, i, j)$ and $(c, j, k)$
are in $\m{chart}$ -- this corresponds to applications of the first rule. The
second clause corresponds to the second rule above, saying that $(a, i, i + length(s))$
is a generated fact if $s$ is a substring of $\mi{text}$ at position $i$.

We can then use $\fname{iter}$ to implement the $\fname{parse}$ function.
%% parse
\[\begin{array}{l}
\fname{parse} ~:~ \str \uto \ms{grammar} \mto \Set{\ms{sym}}\\
\fname{parse} \;\mi{text} \;\m{G} =\\
\hspace{1em} \ms{let}~ n = \ms{length} \;\mi{text}\\
\hspace{2.375em}\m{bound} =
  \{(a,i,j) ~|~ (a,\pwild) \in \m{G},\\
\hspace{10.5em}i \in \ms{range}\;0\;n, \\
\hspace{10.5em}j\in\fname{range}\;i\;n\}\\
\hspace{2.375em} \m{chart} = \fixle{\m{C}}{\m{bound}}
  \ms{iter} \;\mi{text} \;\m{G} \;\m{C}\\
\hspace{1em}\ms{in}~\setfor{a}{(a, 0, n) \in \m{chart}}\\
%% %% iter with \forin
%% \\
%% \fname{iter} \;\mi{text} \;\m{G} \;\m{chart} =\\
%% \hspace{1em}\phantom{\vee~}
%% (\bigvee((a, \ctor{Concat} \;b \;c) \in \m{G},\\
%% \hspace{1.25em}\phantom{\vee~ \bigvee(}
%% (b,i,j) \in \m{chart}, (c,j,k) \in \m{chart})\\
%% \hspace{1.25em}\phantom{\vee~}\, \setlit{(a,i,k)})\\
%% \hspace{1em}\vee~ (\bigvee((a, \ctor{String} \;s) \in \m{G},\\
%% \hspace{1.25em}\phantom{\vee~\bigvee(}
%% i \in \ms{range} \;0 \;(n - \ms{length} \; s),\\
%% \hspace{1.25em}\phantom{\vee~\bigvee(}
%% s = \ms{substring} \;\mi{text} \;i \;(i+\ms{length}\;s))\\
%% \hspace{1.25em}\phantom{\vee~}\, \setlit{(a,i,i+ \ms{length}\;s)})
%% \\
%% %% iter with case. I like this version best.
%% \\
%% \fname{iter} \;\mi{text} \;\m{G} \;\m{chart} =\\
%% \hspace{1em}\forin{(a,r) \in \m{G}}\\
%% \hspace{1.875em}\ms{case}~ r\\
%% \hspace{2.4em}\ms{of}~
%% %% \hspace{3.05em}\pipe
%% \ctor{Concat} \;b \;c \cto \{(a,i,k) ~|~ (b,i,j) \in \m{chart},\\
%% \hspace{14.42em}(c,j,k) \in \m{chart}\}\\
%% \hspace{3.05em}\pipe \ctor{String} \;s \cto
%% \{\,(a, i, i+\ms{length}\;s)\\
%% \hspace{9em}|~ i \in \ms{range} \;0 \;(n-\ms{length}\;s),\\
%% \hspace{9em}\phantom{|~}
%% s = \ms{substring} \;\mi{text} \;i \;(i+\ms{length}\;s)\}
%% \\
%% iter. Neel prefers this. People know set-comprehension.
\end{array}\]
This function just takes the fixed point of $\fname{iter}$ --
almost. Because facts are triples $\ms{sym} \x \N \x \N$, sets of
facts may in general grow unboundedly.  To ensure termination, we
construct a set $\m{bound}$ to bound the sets of facts we consider in
our fixed point computation, by bounding the symbols to names found in
the grammar $\m{G}$, and the indices to positions of the string. Since
all of these are finite, we know that the computation of $\m{chart}$
as a bounded fixed point will terminate. Then, having computed the
fixed point, we can check chart to see if $(a, 0, \ms{length}\;\mi{text})$
is derivable.

There are three things worth noting about this program. First, it is
not expressible in Datalog. Because Datalog provides no way to
represent a \emph{grammar} as a piece of data (it's compound, not an
atom), there is simply no way in Datalog to express a \emph{generic}
parser taking a grammar as an input. This demonstrates one of the key
benefits of moving to a functional language like Datafun.

Moreover, Datalog's strategy for proving termination involves a
constructor restriction to ensure all relations are finite. Primitives such as
\ms{range} and \ms{substring} violate this restriction (as relations, they are
infinite); it is not immediately obvious that Datalog programs extended with
these primitives remain terminating. Our use of bounded fixed-points to
guarantee termination is robust under such extensions; as long as all primitive
functions are total, Datafun programs always terminate.

Finally, having computed a set via a fixed point, we can test whether
or not an element is in that set \emph{or not} -- the ability to test
for negative information after the fixed point computation completes
corresponds to a use of stratified negation in Datalog.


\subsection{Dataflow analysis}

\[\begin{array}{l}
\textbf{type}~\ms{var} = \str\\
\textbf{type}~\ms{label} = \N\\
\textbf{data}~\ms{oper} = \ctor{Eq} \pipe \ctor{Le}
\pipe \ctor{Add} \pipe \ctor{Sub} \pipe\ctor{Mul}\pipe\ctor{Div}\\
\textbf{data}~\ms{atom} = \ctor{Var}\;\ms{var} \pipe \ctor{Num}\;\N\\
\textbf{data}~\ms{expr} = \ctor{Atom}\;\ms{atom}
\pipe \ctor{Apply}\;\ms{oper}\;\ms{atom}\;\ms{atom}\\
\textbf{data}~\ms{stmt} =
\ctor{Assign} \;\ms{var} \;\ms{expr}
\pipe \ctor{If} \;\ms{expr} \;\ms{label}\;\ms{label}
\end{array}\]

%% TODO: rename `code' to `program'?
We represent a program as a set of label, statement pairs. \todo{Explain
  invariant}
\[\begin{array}{l}
\textbf{type}~\ms{code} = \Set{\ms{label} \x \ms{stmt}}
\vspace{0.5em}\\
%% omitted functions
\ms{labels} ~:~ \ms{code} \uto \Set{\ms{label}}\quad\textsf{-{}- omitted}\\
\ms{vars} ~:~ \ms{code} \uto \Set{\ms{var}} \quad\textsf{-{}- omitted}\\
\ms{uses} ~:~ \ms{stmt} \uto \Set{\ms{var}} \quad\textsf{-{}- omitted}\\
\ms{defines} ~:~ \ms{stmt} \uto \Set{\ms{var}} \quad\textsf{-{}- omitted}
\vspace{0.5em}\\
%% control flow
%% TODO: use long variable name for argument.
\textbf{type}~\ms{flow} = \Set{\ms{label} \x \ms{label}}\\
\fname{flow} ~:~ \ms{code} \uto \ms{flow}\\
\fname{flow}\;c = \forin{(i,s) \in c}\\
\hspace{4em}\ms{case}~ s ~\ms{of}~
\ctor{If} \;\pwild \;j \;k \cto \setlit{(i,j),(i,k)}\\
\hspace{7.45em}\pipe\pwild \cto \setfor{(i,i+1)}{i+1 \isin \ms{labels}\;c}
\vspace{0.5em}\\
%% live code analysis
\ms{live} ~:~ \ms{code} \uto \ms{flow} \uto \Set{\ms{label} \x \ms{var}}\\
\ms{live} \;\mi{code} \;\mi{flow} =\\
\hspace{2em} \fixle{\m{Live}}{ %
  \ms{labels}\;\mi{code} \x \ms{vars}\;\mi{code}}\\
\hspace{2em}\forin{(i,\mi{stmt}) \in \mi{code}}\\
\hspace{2.875em} (\phantom{\vee~}\setfor{(i,v)}{v \in \ms{uses}\;\mi{stmt}}\\
\hspace{3.2em} \vee~ \{(i,v) ~|~ (i,j) \in \mi{flow},\\
\hspace{7.4em}(j,v) \in \m{Live},\\
\hspace{7.4em}\neg (v \isin \ms{defines}\; \mi{stmt})\})
\vspace{0.5em}\\
%% reaching definitions analysis
\textsf{\todo{explain which label means what}}\\
\ms{reachingDefinitions} ~:~ \ms{code} \uto \ms{flow}
\uto \Set{\ms{label} \x \ms{label} \x \ms{var}}\\
\ms{reachingDefinitions} \;\mi{code} \;\mi{flow} =\\
\hspace{2em}\fixle{\m{RD}}{%
  \ms{labels}\;\mi{code} \x \ms{labels}\;\mi{code} \x \ms{vars}\;\mi{code}}\\
\hspace{2em}\forin{(i,\mi{stmt}) \in \mi{code}}\\
\hspace{2.875em} (
\phantom{\vee~}\setfor{(i,i,v)}{v \in \ms{defines}\;\mi{stmt}}\\
\hspace{3.2em} \vee~ \{(i,l,v) ~|~ (j,i) \in \mi{flow},\\
\hspace{8.14em}(j,l,v) \in \m{RD},\\
\hspace{8.14em}\neg(v \isin \ms{defines}\;\mi{stmt})\})
\end{array}\]

\TODO
