\section{Other Related and Future Work}
\label{sec:futurework}

\paragraph{Optimization}
\begin{itemize}
\item \TODO the datalog literature
\end{itemize}

\paragraph{Aggregation}
Aggregation of values --- for example, taking the sum $\sum_{x \in A} f \;x$ of
a function $f$ across a set $A$ --- is a common and ubiquitous database
operation. Datafun naturally supports \emph{semilattice} aggregation via
$\bigvee$, but many natural operations such as summation do not form
semilattices on their underlying type. There are several potential ways to add
support for aggregations to Datafun:
\begin{itemize}
\item Common aggregations can be provided as primitive functions, for example
  $\ms{size} : \Set{\eq{A}} \mto \N$ or $\ms{sum} : (\eq{A} \to \N) \uto \Set{A}
  \mto \N$.

\item In the style of Machiavelli~\cite{machiavelli}, one could add a general
  operator $\ms{hom} : B \to (\eq{A} \uto B \uto B) \uto \Set{\eq{A}} \uto B$,
  which effectively linearizes a set in an unspecified order. The semantics of
  \ms{hom} are, alas, necessarily nondeterministic.

\item One could augment Datafun with a type of bags (multisets) $\Bag{A}$; bags
  naturally support a much broader class of aggregation --- commutative monoids
  --- than sets. See, for example, \citet{multilinear-bigdata}.
\end{itemize}

\paragraph{Deletion} \citet{logical-algorithms} showed how
forward-chaining logic programming permits concise and elegant
expression of a wide variety of algorithms, including a natural cost
semantics. However, they noted that there were some algorithms (such
as union-find and greedy algorithms) which could be formulated in this
style, \emph{if} there were additionally support for deleting facts
from a database. Later, \citet{linear-logical-algorithms} went on to
show how deletion could be given a logical interpretation by
formulating in terms of linear logic programming.

This naturally raises the question of whether we could identify a
``linear Datafun'' corresponding to this style of programming, where
we might linear types to model features like deletion. There are many
nontrivial semantic issues (e.g., how to define monotonicity), but
it seems a promising question for future work.

\paragraph{Termination} \TODO nontermination and declarativeness.

For example, one powerful optimization technique is \emph{loop reordering} (in
SQL terminology, \emph{join reordering}), that is, taking advantage of the
equation
\begin{eqnarray*}
  \forin{x \in e_1} \forin{y \in e_2} e
  &=& \forin{y \in e_2} \forin{x \in e_1} e
\end{eqnarray*}
when $x,y \notin \ms{FV}(e_1) \cup \ms{FV}(e_2)$. (\TODO Explain why join
reordering is powerful). But this equation does not always hold in the presence
of nontermination; for example, if $e_1 = \unit$ and $e_2$ diverges. \TODO
finish up

\paragraph{Polymorphism}
\todo{
  \begin{itemize}
  \item ref Dunfield \& Krishnaswami, higher-order bidirectional type inference.
  \item \TODO quantification over different classes of type variable (ordinary,
    equality, lattice); amounts to a typeclass system, so this is not new work
  \item \TODO tone polymorphism and why you need it for principal types; e.g.
    what is the type of $\fn\bind{f}\fn\bind{x} f\;x$?
  \end{itemize}
}

\paragraph{User-Defined Posets and Semilattices}
The two fundamental semilattice types Datafun provides are booleans and sets;
products and functions merely preserve semilattice structure where they find
it. One might contemplate allowing the programmer to define their own
semilattice structures using something like Haskell's
\texttt{newtype}/\texttt{instance}. In general, this is a difficult
problem, because we may need to do serious mathematical
reasoning to prove that a datatype has a partial ordering, or can be
equipped with a semilattice structure which is commutative, associative
and idempotent.

One example of such a family of types are the \emph{lexicographic sum
  types}. Given two posets $P$ and $Q$, their disjoint union $P + Q$
is also a poset, with left values compared by the $P$-ordering, and
right values compared by the $Q$-ordering, and no ordering between
left and right values. However, this is not the only way that the
disjoint union could be equipped with an order structure.

For example, we could define the \emph{lexicographic} sum $P \lhd Q$,
which has the same elements as the sum, but extending the coproduct order
relation with the additional
facts that $\ms{in}_1(p) \leq \ms{in}_2(q)$. Indeed, we already have a
special case of this: as we noted earlier, our boolean type is not $1
+ 1$, but it \emph{is} $1 \lhd 1$.

But as our Booleans already show, giving good syntax for their
eliminators is difficult, because we have to show that not just a term
is monotone, but that the different branches of a lexicographic case
expression are ordered with respect to \emph{each other}. For the case
of ordered Booleans, we were able to give a special eliminator which
guaranteed it, but in general it requires proof.

One natural direction for future work is to extend the syntax of
Datafun with support for these kinds of proofs, perhaps taking
inspiration from dependent type theory.
