\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% numbers       To obtain numeric citation style instead of author/year.

\usepackage{rntz}

\renewcommand{\pipe}{\mathrel{\mid}} %overrides rntz.sty
\newcommand{\uto}{\to}
\newcommand{\rn}[1]{\mathsz{8pt}{\ms{#1}}} %for inference rule names
\def\arraystretch{1.1}                     %a little more spacing, please

%% taken from the source for Dunfield & Krishnaswami's paper "Complete and Easy
%% Bidirectional Typechecking for Higher-Rank Polymorphism"
\newdimen\zzfontsz
\newcommand{\fontsz}[2]{\zzfontsz=#1%
{\fontsize{\zzfontsz}{1.2\zzfontsz}\selectfont{#2}}}
\newcommand{\mathsz}[2]{\text{\fontsz{#1}{$#2$}}}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{ICFP '16}{Month d--d, 2016, City, ST, Country}
\copyrightyear{2016}
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
\copyrightdoi{nnnnnnn.nnnnnnn}

% Uncomment the publication rights you want to use.
%\publicationrights{transferred}
%\publicationrights{licensed}     % this is the default
%\publicationrights{author-pays}

% These are ignored unless 'preprint' option specified.
\titlebanner{preprint}
\preprintfooter{Datafun, or, Datalog with datatypes (PREPRINT)}

\title{Datafun}
\subtitle{or, Datalog with datatypes}
%% \subtitle{a functional Datalog}

\authorinfo{Michael Arntzenius\and Neelakantan R. Krishnaswami}
           {University of Birmingham}
           {Email2/3}

\maketitle


\begin{abstract}
This is the text of the abstract.
\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore,
% you may leave them out
\terms
term1, term2

\keywords
keyword1, keyword2

\section{Introduction}

The text of the paper begins here.

\paragraph{Contributions}

\section{Datafun}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nec vero alia sunt
quaerenda contra Carneadeam illam sententiam. Cum ageremus, inquit, vitae beatum
et eundem supremum diem, scribebamus haec. Quid sequatur, quid repugnet, vident.

Minime id quidem, inquam, alienum, multumque ad ea, quae quaerimus, explicatio
tua ista profecerit. Qua ex cognitione facilior facta est investigatio rerum
occultissimarum. Quis animo aequo videt eum, quem inpure ac flagitiose putet
vivere? Primum quid tu dicis breve? Ita enim vivunt quidam, ut eorum vita
refellatur oratio.


%% FIGURE: CORE SYNTAX
\begin{figure}
  \[\begin{array}{ccl}
    %% types
    A, B     &\bnfeq& \bool \pipe \N \pipe \Str \pipe \Set{A}
                      \pipe \Map{\eq{A}}{B}
    \\
    \textsf{types} && A + B \pipe A \x B \pipe A \uto B \pipe A \mto B
    \vspace{0.5em}\\
    %% usl types
    L, M         &\bnfeq& \bool \pipe \N \pipe \Set{A} \pipe \Map{\eq{A}}{L}
    \\
    \textsf{usl types} && L \x M \pipe A \uto L \pipe A \mto L
    \vspace{0.5em}\\
    %% equality types
    \eq{A}, \eq{B} &\bnfeq& \bool \pipe \N \pipe \Str \pipe \Set{\eq{A}}
                            \pipe \Map{\eq{A}}{\eq{B}}
    \\
    \textsf{eqtypes} && \eq{A} + \eq{B} \pipe \eq{A} \x \eq{B}
    \vspace{0.5em}\\
    %% finite equality types
    \fineq{A},\fineq{B}
    &\bnfeq& \bool \pipe \Set{\fineq{A}}
       \pipe \Map{\fineq{A}}{\fineq{B}}
       \pipe \fineq{A} + \fineq{B} \pipe \fineq{A} \x \fineq{B}\\
    \textsf{finite eqtypes}
    \vspace{0.5em}\\
    %% usl finite eqtypes
    \fineq{L}, \fineq{M}
    &\defeq& \textsf{usl types}~\cap~\textsf{finite eqtypes}
    \vspace{0.5em}\\
    \GD, \GG &\bnfeq& \cdot \pipe \GD, x\of A\\
    \textsf{contexts}\\
    %% expressions
    e &\bnfeq& x \pipe \fn\bind{x} e \pipe e\;e \pipe (e,e) \pipe \pi_i\;e\\
    \textsf{terms} && \ms{in}_i\;e \pipe \case{e}{x}{e}{x}{e}\\
    && e = e \pipe \ms{true} \pipe \ms{false} \pipe \ifthen{e}{e}{e}\\
    && \singleset{e} \pipe \singlemap{e}{e}
       \pipe \unit \pipe e \vee e \pipe \letin{x}{e}{e}\\
    && \fix{x}{e} \pipe \fixle{x}{e}{e}
  \end{array}\]
  \caption{Syntax of core Datafun}
\end{figure}

%% FIGURE: SYNTAX SUGAR
\begin{figure}n
  %% \[\begin{array}{lccl}
  %% %% expressions
  %% \textsf{terms} &
  %% e &\bnfeq& ... \pipe e \isin e \pipe \setfor{e}{\mc{L}}
  %%            \pipe \forin{\mc{L}}{e}\\
  %% &&& \rawcase{e}{[{p} \to {e}]^*}
  %% \vspace{0.5em}\\
  %% %% patterns
  %% \textsf{patterns} &
  %% p &\bnfeq& \pwild \pipe x \pipe (p,p) \pipe \ms{in}_i\;p
  %%            \pipe \ms{true} \pipe \ms{false}
  %% \vspace{0.5em}\\
  %% %% loop clauses
  %% \textsf{loops} &
  %% \mc{L} &\bnfeq& \mc{L}, \mc{L} \pipe p \in e \pipe e
  %% \end{array}\]

  \[\begin{array}{ccl}
  %% expressions
  e         &\bnfeq& ... \pipe e \isin e \pipe \setfor{e}{\mc{L}}
                     \pipe \forin{\mc{L}}{e}\\
  \textsf{terms} && \rawcase{e}{[{p} \to {e}]^*}
  \vspace{0.5em}\\
  %% patterns
  p &\bnfeq& \pwild \pipe x \pipe (p,p) \pipe \ms{in}_i\;p
             \pipe \ms{true} \pipe \ms{false}\\
  \textsf{patterns}
  \vspace{0.5em}\\
  %% loop clauses
  \mc{L} &\bnfeq& \mc{L}, \mc{L} \pipe p \in e \pipe e\\
  \textsf{loops}
  \end{array}\]

  %% the desugaring syntax-expansion itself
  \begin{eqnarray*}
    e_1 \isin e_2            &\expandsto& \forin{x \in e_2} e_1 = x\\
    \setfor{e}{\mc{L}}       &\expandsto& \forin{\mc{L}}{\{e\}}\\
    \forin{\mc{L}_1,\mc{L}_2}{e}
    &\expandsto& \forin{\mc{L}_1}{\forin{\mc{L}_2}{e}}\\
    \forin{p\in e_1}{e_2}
    &\expandsto& \letin{x}{e_1}{\rawcase{x}{p \to e_2;\,\pwild \to \unit}}\\
    \forin{e_1}{e_2} &\expandsto& \ifthen{e_1}{e_2}{\unit}
  \end{eqnarray*}
  \caption{Some useful syntax sugar}
\end{figure}

%% FIGURE: Typing rules
\begin{figure*}
  \boxed{\ensuremath{\mathsz{10pt}{\J{\Delta}{\Gamma}{e}{A}}}}
  \begin{mathpar}
    \infer[\rn{var}]{\J{\GD}{\GG}{x}{A}}{x\of A \in \GD \cup \GG}
    %% function rules
    \and
    \infer[\fn]{\J{\GD}{\GG}{\fn\bind{x} e}{A \uto B}}{
      \J{\GD,x\of A}{\GG}{e}{B}}
    \and
    \infer[\monofn]{\J{\GD}{\GG}{\fn\bind{x} e}{A \mto B}}{
      \J{\GD}{\GG,x \of A}{e}{B}}
    \and
    \infer[\rn{app}]{\J{\GD}{\GG}{e_1\;e_2}{B}}{
      \J{\GD}{\GG}{e_1}{A \uto B} &
      \J{\GD}{\cdot}{e_2}{A}}
    \and
    \infer[\rn{app^+}]{\J{\GD}{\GG}{e_1\;e_2}{B}}{
      \J{\GD}{\GG}{e_1}{A \mto B} &
      \J{\GD}{\GG}{e_2}{A}}
    %% product & sum rules
    \and
    \infer[\rn{pair}]{\J{\GD}{\GG}{(e_1,e_2)}{A_1 \x A_2}}{
      \J{\GD}{\GG}{e_i}{A_i}}
    \and
    \infer[\rn{\pi}]{\J{\GD}{\GG}{\pi_i\;e}{A_i}}{\J{\GD}{\GG}{e}{A_1 \x A_2}}
    \and
    \infer[\rn{in}]{\J{\GD}{\GG}{\ms{in}_i\;e}{A_1 + A_2}}{\J{\GD}{\GG}{e}{A_i}}
    \and
    \infer[\rn{case}]{\J{\GD}{\GG}{\case{e}{x}{e_1}{x}{e_2}}{C}}{
      \J{\GD}{\cdot}{e}{A_1 + A_2} &
      \J{\GD,x\of A_i}{\GG}{e_i}{C}}
    \and
    \infer[\rn{case^+}]{\J{\GD}{\GG}{\case{e}{x}{e_1}{x}{e_2}}{C}}{
      \J{\GD}{\GG}{e}{A_1 + A_2} &
      \J{\GD}{\GG,x\of A_i}{e_i}{C}}
    %% boolean rules
    \and
    \infer[\rn{=}]{\J{\GD}{\GG}{e_1 = e_2}{\bool}}{\J{\GD}{\GG}{e_i}{\eq{A}}}
    \and
    \infer[\rn{true}]{\J{\GD}{\GG}{\ms{true}}{\bool}}{}
    \and
    \infer[\rn{false}]{\J{\GD}{\GG}{\ms{false}}{\bool}}{}
    \and
    \infer[\rn{if}]{\J{\GD}{\GG}{\ifthen{e}{e_1}{e_2}}{A}}{
      \J{\GD}{\cdot}{e}{\bool} &
      \J{\GD}{\GG}{e_i}{A}}
    \and
    \infer[\rn{if^+}]{\J{\GD}{\GG}{\ifthen{e}{e_1}{\unit}}{L}}{
      \J{\GD}{\GG}{e}{\bool} &
      \J{\GD}{\GG}{e_1}{L}}
    %% set & semilattice rules
    \and
    \infer[\rn{\{\}}]{\J{\GD}{\GG}{\{e\}}{\Set{A}}}{\J{\GD}{\cdot}{e}{A}}
    \and
    \infer[\rn{\{:\}}]{\J{\GD}{\GG}{\singlemap{e_1}{e_2}}{\Map{\eq{A}}{B}}}{
      \J{\GD}{\cdot}{e_1}{\eq{A}} &
      \J{\GD}{\GG}{e_2}{B}}
    \and
    \infer[\unit]{\J{\GD}{\GG}{\unit}{L}}{}
    \and
    \infer[\rn{\vee}]{\J{\GD}{\GG}{e_1 \vee e_2}{L}}{\J{\GD}{\GG}{e_i}{L}}
    \and
    \infer[\rn{\bigvee}]{\J{\GD}{\GG}{\letin{x}{e_1}{e_2}}{L}}{
      \J{\GD}{\GG}{e_1}{\Set{A}} &
      \J{\GD,x\of A}{\GG}{e_2}{L}}
    \and
    \infer[\rn{fix}]{\J{\GD}{\GG}{\fix{x}{e}}{\fineq{L}}}{
      \J{\GD}{\GG,x\of L}{e}{\fineq{L}}}
    \and
    \infer[\rn{fix_{\le}}]{\J{\GD}{\GG}{\fixle{x}{e_1}{e_2}}{\eq{L}}}{
      \J{\GD}{\GG}{e_1}{\eq{L}} &
      \J{\GD}{\GG,x \of \eq{L}}{e_2}{\eq{L}}}
  \end{mathpar}

  \caption{Typing rules for core Datafun}
\end{figure*}

\newcommand{\fname}{\ms}
\begin{figure}
  \[\begin{array}{cll}
  \le &\of& \eq{A} \uto \eq{A} \uto \bool\\
  \fname{keys}     &:& \Map{\eq{A}}{B} \mto \Set{\eq{A}}\\
  \fname{tabulate} &:& \Set{\eq{A}} \mto (\eq{A} \to B) \mto \Map{\eq{A}}{B}\\
  \fname{getWith}  &:& \Map{\eq{A}}{B} \mto \eq{A} \uto (B \mto L) \mto L\\
  \fname{get}      &:& \Map{\eq{A}}{L} \mto \eq{A} \uto L\\
  %% \fname{substrings} &\of& \ms{Str} \to \Set{\ms{Str}}\\
  %% \fname{size}     &:& \Set{\eq{A}} \mto \N\\
  \end{array}\]
  \caption{Built-in functions and their type schemes}
\end{figure}


%%
\section{Datafun by example}

\section{Semantics}

\section{Implementation}
We have built a prototype implementation of Datafun in Racket \todo{CITE}. In
addition to core Datafun, it supports pattern-matching, record types, subtyping,
antitone functions and variables, and unbounded (potentially nonterminating)
fixed points. It has no optimizations whatsoever.

\todo{LINK}

%% not sure how many sections to split this up into.
\section{Tradeoffs, limitations, and design decisions}
\section{Related and future work}

%% ACKNOWLEDGMENTS
\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}
\bibliography{datafun}

%% \appendix
%% \section{Appendix Title}

%% This is the text of the appendix, if you need one.


\end{document}
