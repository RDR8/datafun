\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% numbers       To obtain numeric citation style instead of author/year.

\usepackage{rntz}

\renewcommand{\pipe}{\mathrel{\mid}} %overrides rntz.sty
\newcommand{\uto}{\to}
\newcommand{\rn}[1]{\mathsz{8pt}{\ms{#1}}} %for inference rule names
\def\arraystretch{1.1}                     %a little more spacing, please

%% taken from the source for Dunfield & Krishnaswami's paper "Complete and Easy
%% Bidirectional Typechecking for Higher-Rank Polymorphism"
\newdimen\zzfontsz
\newcommand{\fontsz}[2]{\zzfontsz=#1%
{\fontsize{\zzfontsz}{1.2\zzfontsz}\selectfont{#2}}}
\newcommand{\mathsz}[2]{\text{\fontsz{#1}{$#2$}}}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{ICFP '16}{Month d--d, 2016, City, ST, Country}
\copyrightyear{2016}
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
\copyrightdoi{nnnnnnn.nnnnnnn}

% Uncomment the publication rights you want to use.
%\publicationrights{transferred}
%\publicationrights{licensed}     % this is the default
%\publicationrights{author-pays}

% These are ignored unless 'preprint' option specified.
\titlebanner{preprint}
\preprintfooter{Datafun, or, Datalog with datatypes (PREPRINT)}

\title{Datafun: a Functional Datalog}
%% \subtitle{}

%% \title{Datafun}
%% \subtitle{A Functional Datalog}

%% \title{Datafun}
%% \subtitle{or, Datalog with datatypes}

%% \title{Datalog with Datatypes}
%% \subtitle{Toward a functional language of finite sets}

\authorinfo{Michael Arntzenius\and Neelakantan R. Krishnaswami}
           {University of Birmingham}
           {Email2/3}

\maketitle


\begin{abstract}
This is the text of the abstract.
\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore,
% you may leave them out
\terms
term1, term2

\keywords
keyword1, keyword2

\section{Introduction}

The text of the paper begins here.

\paragraph{Contributions}
\begin{itemize}
\item foo
\end{itemize}

%% Notes from skype with Neel:

% Contributions:
%
% - Datafun: like datalog but functional
%
% - give many examples, some classic datalog problems, some datalog can't do
%
% - denotational semantics based on 2 adjunctions found by analysing
%   semantics of datalog
%
% - prototype implementation

\section{Datafun}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nec vero alia sunt
quaerenda contra Carneadeam illam sententiam. Cum ageremus, inquit, vitae beatum
et eundem supremum diem, scribebamus haec. Quid sequatur, quid repugnet, vident.

Minime id quidem, inquam, alienum, multumque ad ea, quae quaerimus, explicatio
tua ista profecerit. Qua ex cognitione facilior facta est investigatio rerum
occultissimarum. Quis animo aequo videt eum, quem inpure ac flagitiose putet
vivere? Primum quid tu dicis breve? Ita enim vivunt quidam, ut eorum vita
refellatur oratio.


%% FIGURE: CORE SYNTAX
\begin{figure}
  \[\begin{array}{ccl}
    %% types
    A, B     &\bnfeq& \bool \pipe \N \pipe \str \pipe \Set{A}
                      \pipe \Map{A}{B}
    \\
    \textsf{types} && A + B \pipe A \x B \pipe A \uto B \pipe A \mto B
    \vspace{0.5em}\\
    %% usl types
    L, M         &\bnfeq& \bool \pipe \N \pipe \Set{A} \pipe \Map{A}{L}
    \\
    \textsf{usl types} && L \x M \pipe A \uto L \pipe A \mto L
    \vspace{0.5em}\\
    %% equality types
    \eq{A}, \eq{B} &\bnfeq& \bool \pipe \N \pipe \str \pipe \Set{\eq{A}}
                            \pipe \Map{\eq{A}}{\eq{B}}
    \\
    \textsf{eqtypes} && \eq{A} + \eq{B} \pipe \eq{A} \x \eq{B}
    \vspace{0.5em}\\
    %% contexts
    \GD, \GG &\bnfeq& \cdot \pipe \GD, x\of A\\
    \textsf{contexts}\\
    %% expressions
    e &\bnfeq& x \pipe \fn\bind{x} e \pipe e\;e \pipe (e,e) \pipe \pi_i\;e\\
    \textsf{terms} && \ms{in}_i\;e \pipe \case{e}{x}{e}{x}{e}\\
    && e = e \pipe \ms{true} \pipe \ms{false} \pipe \ifthen{e}{e}{e}\\
    && \singleset{e} \pipe \singlemap{e}{e}
       \pipe \unit \pipe e \vee e \pipe \letin{x}{e}{e}\\
    && %% \fix{x}{e} \pipe
       \fixle{x}{e}{e}
  \end{array}\]
  \caption{Syntax of core Datafun}
\end{figure}

%% FIGURE: SYNTAX SUGAR
\begin{figure}
  \[\begin{array}{lccl}
  %% expressions
  \textsf{terms} &
  e &\bnfeq& ... \pipe e \isin e \pipe \setfor{e}{\mc{L}}
             \pipe \forin{\mc{L}}{e}\\
  &&& \mathcal{C}[\;e]^* \pipe \rawcase{e}{[{p} \to {e}]^*}\\
  &&& \ms{let}~ [x = e]^* ~\ms{in}~ e
  \vspace{0.5em}\\
  %% patterns
  \textsf{patterns} &
  p &\bnfeq& \pwild \pipe x \pipe (p,p)
             \pipe \ms{true} \pipe \ms{false} \pipe \mathcal{C}[\;p]^*
  \vspace{0.5em}\\
  \textsf{constructors} & \mathcal{C} && \text{are abstract identifiers}
  \vspace{0.5em}\\
  %% loop clauses
  \textsf{loops} &
  \mc{L} &\bnfeq& \mc{L}, \mc{L} \pipe p \in e \pipe e
  \end{array}\]

  %% \[\begin{array}{ccl}
  %% %% expressions
  %% e         &\bnfeq& ... \pipe e \isin e \pipe \setfor{e}{\mc{L}}
  %%                    \pipe \forin{\mc{L}}{e}\\
  %% \textsf{terms} && \rawcase{e}{[{p} \to {e}]^*}
  %% \vspace{0.5em}\\
  %% %% patterns
  %% p &\bnfeq& \pwild \pipe x \pipe (p,p) \pipe \ms{in}_i\;p
  %%            \pipe \ms{true} \pipe \ms{false}\\
  %% \textsf{patterns}
  %% \vspace{0.5em}\\
  %% %% loop clauses
  %% \mc{L} &\bnfeq& \mc{L}, \mc{L} \pipe p \in e \pipe e\\
  %% \textsf{loops}
  %% \end{array}\]

  %% TODO: constructors?

  %% the desugaring syntax-expansion itself
  \begin{eqnarray*}
    e_1 \isin e_2            &\expandsto& \forin{x \in e_2} e_1 = x\\
    \setfor{e}{\mc{L}}       &\expandsto& \forin{\mc{L}}{\{e\}}\\
    \forin{\mc{L}_1,\mc{L}_2}{e}
    &\expandsto& \forin{\mc{L}_1}{\forin{\mc{L}_2}{e}}\\
    \forin{p\in e_1}{e_2}
    &\expandsto& \letin{x}{e_1}{\rawcase{x}{p \to e_2;\,\pwild \to \unit}}\\
    \forin{e_1}{e_2} &\expandsto& \ifthen{e_1}{e_2}{\unit}\\
    \ms{let}~x = e_1 ~\ms{in}~ e_2
    &\expandsto& (\fn\bind{x} e_2)\; e_1\\
    \ms{let}~[x_i = e_i]^* ~\ms{in}~ e
    &\expandsto& [\ms{let}~x_i = e_i~\ms{in}]^* e
  \end{eqnarray*}
  \caption{Syntax sugar}
\end{figure}

%% FIGURE: Typing rules
\begin{figure*}
  \boxed{\ensuremath{\mathsz{10pt}{\J{\Delta}{\Gamma}{e}{A}}}}
  \begin{mathpar}
    \infer[\rn{var}]{\J{\GD}{\GG}{x}{A}}{x\of A \in \GD \cup \GG}
    %% function rules
    \and
    \infer[\fn]{\J{\GD}{\GG}{\fn\bind{x} e}{A \uto B}}{
      \J{\GD,x\of A}{\GG}{e}{B}}
    \and
    \infer[\monofn]{\J{\GD}{\GG}{\fn\bind{x} e}{A \mto B}}{
      \J{\GD}{\GG,x \of A}{e}{B}}
    \and
    \infer[\rn{app}]{\J{\GD}{\GG}{e_1\;e_2}{B}}{
      \J{\GD}{\GG}{e_1}{A \uto B} &
      \J{\GD}{\cdot}{e_2}{A}}
    \and
    \infer[\rn{app^+}]{\J{\GD}{\GG}{e_1\;e_2}{B}}{
      \J{\GD}{\GG}{e_1}{A \mto B} &
      \J{\GD}{\GG}{e_2}{A}}
    %% product & sum rules
    \and
    \infer[\rn{pair}]{\J{\GD}{\GG}{(e_1,e_2)}{A_1 \x A_2}}{
      \J{\GD}{\GG}{e_i}{A_i}}
    \and
    \infer[\rn{\pi}]{\J{\GD}{\GG}{\pi_i\;e}{A_i}}{\J{\GD}{\GG}{e}{A_1 \x A_2}}
    \and
    \infer[\rn{in}]{\J{\GD}{\GG}{\ms{in}_i\;e}{A_1 + A_2}}{\J{\GD}{\GG}{e}{A_i}}
    \and
    \infer[\rn{case}]{\J{\GD}{\GG}{\case{e}{x}{e_1}{x}{e_2}}{C}}{
      \J{\GD}{\cdot}{e}{A_1 + A_2} &
      \J{\GD,x\of A_i}{\GG}{e_i}{C}}
    \and
    \infer[\rn{case^+}]{\J{\GD}{\GG}{\case{e}{x}{e_1}{x}{e_2}}{C}}{
      \J{\GD}{\GG}{e}{A_1 + A_2} &
      \J{\GD}{\GG,x\of A_i}{e_i}{C}}
    %% boolean rules
    \and
    \infer[\rn{=}]{\J{\GD}{\GG}{e_1 = e_2}{\bool}}{\J{\GD}{\GG}{e_i}{\eq{A}}}
    \and
    \infer[\rn{true}]{\J{\GD}{\GG}{\ms{true}}{\bool}}{}
    \and
    \infer[\rn{false}]{\J{\GD}{\GG}{\ms{false}}{\bool}}{}
    \and
    \infer[\rn{if}]{\J{\GD}{\GG}{\ifthen{e}{e_1}{e_2}}{A}}{
      \J{\GD}{\cdot}{e}{\bool} &
      \J{\GD}{\GG}{e_i}{A}}
    \and
    \infer[\rn{if^+}]{\J{\GD}{\GG}{\ifthen{e}{e_1}{\unit}}{L}}{
      \J{\GD}{\GG}{e}{\bool} &
      \J{\GD}{\GG}{e_1}{L}}
    %% set & semilattice rules
    \and
    \infer[\rn{\{\}}]{\J{\GD}{\GG}{\{e\}}{\Set{A}}}{\J{\GD}{\cdot}{e}{A}}
    \and
    \infer[\rn{\{:\}}]{\J{\GD}{\GG}{\singlemap{e_1}{e_2}}{\Map{A}{B}}}{
      \J{\GD}{\cdot}{e_1}{\eq{A}} &
      \J{\GD}{\GG}{e_2}{B}}
    \and
    \infer[\unit]{\J{\GD}{\GG}{\unit}{L}}{}
    \and
    \infer[\rn{\vee}]{\J{\GD}{\GG}{e_1 \vee e_2}{L}}{\J{\GD}{\GG}{e_i}{L}}
    \and
    \infer[\rn{\bigvee}]{\J{\GD}{\GG}{\letin{x}{e_1}{e_2}}{L}}{
      \J{\GD}{\GG}{e_1}{\Set{A}} &
      \J{\GD,x\of A}{\GG}{e_2}{L}}
    %% \and
    %% \infer[\rn{fix}]{\J{\GD}{\GG}{\fix{x}{e}}{\fineq{L}}}{
    %%   \J{\GD}{\GG,x\of L}{e}{\fineq{L}}}
    \and
    \infer[\rn{fix_{\le}}]{\J{\GD}{\GG}{\fixle{x}{e_1}{e_2}}{\eq{L}}}{
      \J{\GD}{\GG}{e_1}{\eq{L}} &
      \J{\GD}{\GG,x \of \eq{L}}{e_2}{\eq{L}}}
  \end{mathpar}

  \caption{Typing rules for core Datafun}
\end{figure*}

\newcommand{\fname}{\ms}
\begin{figure}
  \[\begin{array}{cll}
  \le &\of& \eq{A} \uto \eq{A} \mto \bool\\
  \fname{keys}     &:& \Map{A}{B} \mto \Set{A}\\
  \fname{tabulate} &:& \Set{A} \mto (A \to B) \mto \Map{A}{B}\\
  %% \fname{getWith}  &:& \Map{\eq{A}}{B} \mto \eq{A} \uto (B \mto L) \mto L\\
  \fname{get}      &:& \Map{\eq{A}}{L} \mto \eq{A} \uto L\\
  %% \fname{substrings} &\of& \ms{Str} \to \Set{\ms{Str}}\\
  %% \fname{size}     &:& \Set{\eq{A}} \mto \N\\
  \fname{range}    &:& \N \uto \N \mto \Set{\N}\\
  \fname{length}   &:& \str \uto \N\\
  \fname{substring} &:& \str \uto \N \uto \N \uto \str
  \end{array}\]
  \caption{Built-in functions and their type schemes}
\end{figure}


%%
\pagebreak
\section{Datafun by example}

%% Examples

\subsection{Transitive closure}

% what's a good example for parenthood? a dickens novel?
% how about Tolkien?

\[\begin{array}{l}
\ms{persons} ~:~ \Set{\str}\\
\ms{persons} = \{\texttt{"e\"arendil"}, \texttt{"elrond"}, \texttt{"arwen"}\}\\
\ms{parent}, \ms{ancestor} ~:~ \Set{\str \x \str}\\
\ms{parent} = \{(\texttt{"e\"arendil"}, \texttt{"elrond"}),
(\texttt{"elrond"}, \texttt{"arwen"})\}\\
\ms{ancestor} = \fixle{S}{\setfor{(a,b)}{a \in \ms{person}, b \in \ms{person}}}
\\
\hspace{4.87em}\ms{parent} \vee
\setfor{(a,c)}{(a,b) \in \ms{parent}, (b,c) \in S}
\end{array}\]

\subsection{Generic transitive closure}

For any eqtype $\eq{A}$, we may write:
\[\begin{array}{l}
\ms{trans} ~:~
\Set{\eq{A}} \mto \Set{\eq{A} \x \eq{A}} \mto \Set{\eq{A} \x \eq{A}}
\vspace{0.3em}\\
\ms{trans}\ V\ E = \ms{fix}~ S \le \setfor{(a,b)}{a\in V, b \in V}
\\
\hspace{5.35em}\ms{is}~ E \vee \setfor{(a,c)}{(a,b) \in E, (b,c) \in S}
\end{array}\]

\subsection{CYK parsing}

\[\begin{array}{l}
\mathbf{type}~\ms{sym} = \str\\
\mathbf{data}~\ms{rule} = \ctor{String}~\str ~|~ \ctor{Cat}~\ms{sym}~\ms{sym}\\
\mathbf{type}~\ms{grammar} = \Set{\ms{sym} \x \ms{rule}}\\
\mathbf{type}~\ms{fact} = \ms{sym} \x \N \x \N\\
\fname{parse} ~:~ \str \uto \ms{grammar} \mto \Set{\ms{sym}}\\
\fname{iter} ~:~ \str \uto \ms{grammar} \mto \Set{\ms{fact}}
\mto \Set{\ms{fact}}\\
\fname{parse}\;w\;g =\\
\hspace{1em} \ms{let}~ n = \ms{length}\;w\\
\hspace{2.375em}u \overset{+}{=}
  \setfor{(a,i,j)}{(a,\pwild) \in g, i \in \ms{range}\;0\;n,
  j\in\fname{range}\;i\;n}\\
\hspace{1em}\ms{in}~\setfor{a}{(a, 0, n) \in \fixle{S}{u} \ms{iter}\;w\;g\;S}\\
\fname{iter}\;w\;g\;s =\\
\hspace{1em}\phantom{\vee~}\setfor{(a,i,k)}{(a, \ctor{Cat}~b~c) \in g,
  (b,i,j) \in s, (c,j,k) \in s}\\
\hspace{1em}\vee~ \{(a,i,i+\fname{length}\;s)\\
\hspace{2.1em}|~ (a, \ctor{String}~s) \in g,
i \in \fname{range}\;0\;(n-\fname{length}\;s),\\
\hspace{2.2em}\phantom{|~} s = \fname{substring}\;w\;i\;(i+\ms{length}\;s)\}
\end{array}\]


\section{Semantics}

\section{Implementation}
We have built a proof-of-concept implementation of Datafun in Racket
\todo{CITE}. In addition to core Datafun, it supports pattern-matching, variant
types, record types, subtyping, antitone functions, and unbounded (potentially
nonterminating) fixed points. It performs no optimizations whatsoever.

\todo{LINK}

%% not sure how many sections to split this up into.
\section{Tradeoffs, limitations, and design decisions}

\paragraph{Bounded fix-points and the constructor restriction} \todo{Discuss
  datalog's constructor restriction (name?), not being sure how to encode it in
  a type theory, its disadvantages, and the disadvantages of our approach ---
  finitude \& bounded fixed-points}

\todo{in particular, could bounded fix-points have adverse performance
  implications?}

\paragraph{Termination} \todo{discuss nontermination and declarativeness}

\paragraph{Type inference} Typechecking needs to distinguish between ordinary
and monotone $\lambda$, application, \ms{case}, \ms{let}, and \ms{if}. In our
implementation we solve this in two ways:
\begin{enumerate}
\item Bidirectional type inference \todo{CITE} determines whether $\fn$s and
  applications are ordinary or monotone.
\item For $\ms{if}$, $\ms{case}$, and $\ms{let}$, the programmer annotates which
  form is intended; for example, $(\ifthen{e}{e_1}{\unit})$ is written
  (\texttt{when e then e1}) to indicate the rule $\ms{if}^+$ applies.
\end{enumerate}

It remains an open question how much annotation is necessary. We speculate that
bidirectional inference could be replaced by a Damas-Milner\todo{CITE} style
algorithm, which infers a principal type for any term without any annotation at
all, \emph{if} we add polymorphism, tone-polymorphism, and subtyping---so that,
for example, $\fn\bind{f}\fn\bind{x} f\;x$ can be assigned the principal type
$\forall\bind{o\of\ms{tone}}\forall\bind{\alpha,\beta \of \ms{type}} (\alpha
\overset{o}\to \beta) \mto (\alpha \overset{o}\to \beta)$, where
$\overset{o}\to$ indicates a function of tone $o$, which may be empty (for an
ordinary function) or ${+}$ for a monotone function.

\todo{does Neel think this is a reasonable conjecture?}

\section{Related and future work}

%% ACKNOWLEDGMENTS
\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}
\bibliography{datafun}

%% \appendix
%% \section{Appendix Title}

%% This is the text of the appendix, if you need one.


\end{document}
