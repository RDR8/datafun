\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% numbers       To obtain numeric citation style instead of author/year.

\usepackage{rntz}

\renewcommand{\pipe}{\mathrel{\mid}} %overrides rntz.sty
\newcommand{\uto}{\to}
\newcommand{\rn}[1]{\mathsz{8pt}{\ms{#1}}} %for inference rule names
\def\arraystretch{1.1}                     %a little more spacing, please

%% taken from the source for Dunfield & Krishnaswami's paper "Complete and Easy
%% Bidirectional Typechecking for Higher-Rank Polymorphism"
\newdimen\zzfontsz
\newcommand{\fontsz}[2]{\zzfontsz=#1%
{\fontsize{\zzfontsz}{1.2\zzfontsz}\selectfont{#2}}}
\newcommand{\mathsz}[2]{\text{\fontsz{#1}{$#2$}}}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{ICFP '16}{Month d--d, 2016, City, ST, Country}
\copyrightyear{2016}
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
\copyrightdoi{nnnnnnn.nnnnnnn}

% Uncomment the publication rights you want to use.
%\publicationrights{transferred}
%\publicationrights{licensed}     % this is the default
%\publicationrights{author-pays}

% These are ignored unless 'preprint' option specified.
\titlebanner{preprint}
\preprintfooter{Datafun, or, Datalog with datatypes (PREPRINT)}

\title{Datafun: a Functional Datalog}
%% \subtitle{}

%% \title{Datafun}
%% \subtitle{A Functional Datalog}

%% \title{Datafun}
%% \subtitle{or, Datalog with datatypes}

%% \title{Datalog with Datatypes}
%% \subtitle{Toward a functional language of finite sets}

\authorinfo{Michael Arntzenius\and Neelakantan R. Krishnaswami}
           {University of Birmingham}
           {Email2/3}

\maketitle


\begin{abstract}
This is the text of the abstract.
\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore,
% you may leave them out
\terms
term1, term2

\keywords
keyword1, keyword2

\section{Introduction}

The text of the paper begins here.

\paragraph{Contributions}
\begin{itemize}
\item foo
\end{itemize}

%% Notes from skype with Neel:

% Contributions:
%
% - Datafun: like datalog but functional
%
% - give many examples, some classic datalog problems, some datalog can't do
%
% - denotational semantics based on 2 adjunctions found by analysing
%   semantics of datalog
%
% - prototype implementation

\section{Datafun}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nec vero alia sunt
quaerenda contra Carneadeam illam sententiam. Cum ageremus, inquit, vitae beatum
et eundem supremum diem, scribebamus haec. Quid sequatur, quid repugnet, vident.

Minime id quidem, inquam, alienum, multumque ad ea, quae quaerimus, explicatio
tua ista profecerit. Qua ex cognitione facilior facta est investigatio rerum
occultissimarum. Quis animo aequo videt eum, quem inpure ac flagitiose putet
vivere? Primum quid tu dicis breve? Ita enim vivunt quidam, ut eorum vita
refellatur oratio.


%% FIGURE: CORE SYNTAX
\begin{figure}
  \[\begin{array}{ccl}
    %% types
    A, B     &\bnfeq& \bool \pipe \N \pipe \Str \pipe \Set{A}
                      \pipe \Map{A}{B}
    \\
    \textsf{types} && A + B \pipe A \x B \pipe A \uto B \pipe A \mto B
    \vspace{0.5em}\\
    %% usl types
    L, M         &\bnfeq& \bool \pipe \N \pipe \Set{A} \pipe \Map{A}{L}
    \\
    \textsf{usl types} && L \x M \pipe A \uto L \pipe A \mto L
    \vspace{0.5em}\\
    %% equality types
    \eq{A}, \eq{B} &\bnfeq& \bool \pipe \N \pipe \Str \pipe \Set{\eq{A}}
                            \pipe \Map{\eq{A}}{\eq{B}}
    \\
    \textsf{eqtypes} && \eq{A} + \eq{B} \pipe \eq{A} \x \eq{B}
    \vspace{0.5em}\\
    %% finite equality types
    \fineq{A},\fineq{B}
    &\bnfeq& \bool \pipe \Set{\fineq{A}}
       \pipe \Map{\fineq{A}}{\fineq{B}}
       \pipe \fineq{A} + \fineq{B} \pipe \fineq{A} \x \fineq{B}\\
    \textsf{finite eqtypes}
    \vspace{0.5em}\\
    %% usl (finite) eqtypes
    %% \eq{L}, \eq{M} &\defeq& \textsf{usl types}~\cap~\textsf{eqtypes}
    %% \vspace{0.5em}\\
    %% \fineq{L}, \fineq{M}
    %% &\defeq& \textsf{usl types}~\cap~\textsf{finite eqtypes}
    %% \vspace{0.5em}\\
    %% contexts
    \GD, \GG &\bnfeq& \cdot \pipe \GD, x\of A\\
    \textsf{contexts}\\
    %% expressions
    e &\bnfeq& x \pipe \fn\bind{x} e \pipe e\;e \pipe (e,e) \pipe \pi_i\;e\\
    \textsf{terms} && \ms{in}_i\;e \pipe \case{e}{x}{e}{x}{e}\\
    && e = e \pipe \ms{true} \pipe \ms{false} \pipe \ifthen{e}{e}{e}\\
    && \singleset{e} \pipe \singlemap{e}{e}
       \pipe \unit \pipe e \vee e \pipe \letin{x}{e}{e}\\
    && \fix{x}{e} \pipe \fixle{x}{e}{e}
  \end{array}\]
  \caption{Syntax of core Datafun}
\end{figure}

%% FIGURE: SYNTAX SUGAR
\begin{figure}
  \[\begin{array}{lccl}
  %% expressions
  \textsf{terms} &
  e &\bnfeq& ... \pipe e \isin e \pipe \setfor{e}{\mc{L}}
             \pipe \forin{\mc{L}}{e}\\
  &&& \mathcal{C}\;e \pipe \rawcase{e}{[{p} \to {e}]^*}
  \vspace{0.5em}\\
  %% patterns
  \textsf{patterns} &
  p &\bnfeq& \pwild \pipe x \pipe (p,p)
             \pipe \ms{true} \pipe \ms{false} \pipe \mathcal{C}\;p
  \vspace{0.5em}\\
  \textsf{constructors} & \mathcal{C} && \text{are abstract identifiers}
  \vspace{0.5em}\\
  %% loop clauses
  \textsf{loops} &
  \mc{L} &\bnfeq& \mc{L}, \mc{L} \pipe p \in e \pipe e
  \end{array}\]

  %% \[\begin{array}{ccl}
  %% %% expressions
  %% e         &\bnfeq& ... \pipe e \isin e \pipe \setfor{e}{\mc{L}}
  %%                    \pipe \forin{\mc{L}}{e}\\
  %% \textsf{terms} && \rawcase{e}{[{p} \to {e}]^*}
  %% \vspace{0.5em}\\
  %% %% patterns
  %% p &\bnfeq& \pwild \pipe x \pipe (p,p) \pipe \ms{in}_i\;p
  %%            \pipe \ms{true} \pipe \ms{false}\\
  %% \textsf{patterns}
  %% \vspace{0.5em}\\
  %% %% loop clauses
  %% \mc{L} &\bnfeq& \mc{L}, \mc{L} \pipe p \in e \pipe e\\
  %% \textsf{loops}
  %% \end{array}\]

  %% TODO: constructors?

  %% the desugaring syntax-expansion itself
  \begin{eqnarray*}
    e_1 \isin e_2            &\expandsto& \forin{x \in e_2} e_1 = x\\
    \setfor{e}{\mc{L}}       &\expandsto& \forin{\mc{L}}{\{e\}}\\
    \forin{\mc{L}_1,\mc{L}_2}{e}
    &\expandsto& \forin{\mc{L}_1}{\forin{\mc{L}_2}{e}}\\
    \forin{p\in e_1}{e_2}
    &\expandsto& \letin{x}{e_1}{\rawcase{x}{p \to e_2;\,\pwild \to \unit}}\\
    \forin{e_1}{e_2} &\expandsto& \ifthen{e_1}{e_2}{\unit}
  \end{eqnarray*}
  \caption{Syntax sugar}
\end{figure}

%% FIGURE: Typing rules
\begin{figure*}
  \boxed{\ensuremath{\mathsz{10pt}{\J{\Delta}{\Gamma}{e}{A}}}}
  \begin{mathpar}
    \infer[\rn{var}]{\J{\GD}{\GG}{x}{A}}{x\of A \in \GD \cup \GG}
    %% function rules
    \and
    \infer[\fn]{\J{\GD}{\GG}{\fn\bind{x} e}{A \uto B}}{
      \J{\GD,x\of A}{\GG}{e}{B}}
    \and
    \infer[\monofn]{\J{\GD}{\GG}{\fn\bind{x} e}{A \mto B}}{
      \J{\GD}{\GG,x \of A}{e}{B}}
    \and
    \infer[\rn{app}]{\J{\GD}{\GG}{e_1\;e_2}{B}}{
      \J{\GD}{\GG}{e_1}{A \uto B} &
      \J{\GD}{\cdot}{e_2}{A}}
    \and
    \infer[\rn{app^+}]{\J{\GD}{\GG}{e_1\;e_2}{B}}{
      \J{\GD}{\GG}{e_1}{A \mto B} &
      \J{\GD}{\GG}{e_2}{A}}
    %% product & sum rules
    \and
    \infer[\rn{pair}]{\J{\GD}{\GG}{(e_1,e_2)}{A_1 \x A_2}}{
      \J{\GD}{\GG}{e_i}{A_i}}
    \and
    \infer[\rn{\pi}]{\J{\GD}{\GG}{\pi_i\;e}{A_i}}{\J{\GD}{\GG}{e}{A_1 \x A_2}}
    \and
    \infer[\rn{in}]{\J{\GD}{\GG}{\ms{in}_i\;e}{A_1 + A_2}}{\J{\GD}{\GG}{e}{A_i}}
    \and
    \infer[\rn{case}]{\J{\GD}{\GG}{\case{e}{x}{e_1}{x}{e_2}}{C}}{
      \J{\GD}{\cdot}{e}{A_1 + A_2} &
      \J{\GD,x\of A_i}{\GG}{e_i}{C}}
    \and
    \infer[\rn{case^+}]{\J{\GD}{\GG}{\case{e}{x}{e_1}{x}{e_2}}{C}}{
      \J{\GD}{\GG}{e}{A_1 + A_2} &
      \J{\GD}{\GG,x\of A_i}{e_i}{C}}
    %% boolean rules
    \and
    \infer[\rn{=}]{\J{\GD}{\GG}{e_1 = e_2}{\bool}}{\J{\GD}{\GG}{e_i}{\eq{A}}}
    \and
    \infer[\rn{true}]{\J{\GD}{\GG}{\ms{true}}{\bool}}{}
    \and
    \infer[\rn{false}]{\J{\GD}{\GG}{\ms{false}}{\bool}}{}
    \and
    \infer[\rn{if}]{\J{\GD}{\GG}{\ifthen{e}{e_1}{e_2}}{A}}{
      \J{\GD}{\cdot}{e}{\bool} &
      \J{\GD}{\GG}{e_i}{A}}
    \and
    \infer[\rn{if^+}]{\J{\GD}{\GG}{\ifthen{e}{e_1}{\unit}}{L}}{
      \J{\GD}{\GG}{e}{\bool} &
      \J{\GD}{\GG}{e_1}{L}}
    %% set & semilattice rules
    \and
    \infer[\rn{\{\}}]{\J{\GD}{\GG}{\{e\}}{\Set{A}}}{\J{\GD}{\cdot}{e}{A}}
    \and
    \infer[\rn{\{:\}}]{\J{\GD}{\GG}{\singlemap{e_1}{e_2}}{\Map{A}{B}}}{
      \J{\GD}{\cdot}{e_1}{\eq{A}} &
      \J{\GD}{\GG}{e_2}{B}}
    \and
    \infer[\unit]{\J{\GD}{\GG}{\unit}{L}}{}
    \and
    \infer[\rn{\vee}]{\J{\GD}{\GG}{e_1 \vee e_2}{L}}{\J{\GD}{\GG}{e_i}{L}}
    \and
    \infer[\rn{\bigvee}]{\J{\GD}{\GG}{\letin{x}{e_1}{e_2}}{L}}{
      \J{\GD}{\GG}{e_1}{\Set{A}} &
      \J{\GD,x\of A}{\GG}{e_2}{L}}
    \and
    \infer[\rn{fix}]{\J{\GD}{\GG}{\fix{x}{e}}{\fineq{L}}}{
      \J{\GD}{\GG,x\of L}{e}{\fineq{L}}}
    \and
    \infer[\rn{fix_{\le}}]{\J{\GD}{\GG}{\fixle{x}{e_1}{e_2}}{\eq{L}}}{
      \J{\GD}{\GG}{e_1}{\eq{L}} &
      \J{\GD}{\GG,x \of \eq{L}}{e_2}{\eq{L}}}
  \end{mathpar}

  \caption{Typing rules for core Datafun}
\end{figure*}

\newcommand{\fname}{\ms}
\begin{figure}
  \[\begin{array}{cll}
  \le &\of& \eq{A} \uto \eq{A} \mto \bool\\
  \fname{keys}     &:& \Map{A}{B} \mto \Set{A}\\
  \fname{tabulate} &:& \Set{A} \mto (A \to B) \mto \Map{A}{B}\\
  \fname{getWith}  &:& \Map{\eq{A}}{B} \mto \eq{A} \uto (B \mto L) \mto L\\
  \fname{get}      &:& \Map{\eq{A}}{L} \mto \eq{A} \uto L\\
  %% \fname{substrings} &\of& \ms{Str} \to \Set{\ms{Str}}\\
  %% \fname{size}     &:& \Set{\eq{A}} \mto \N\\
  \fname{range}    &:& \N \to \N \mto \Set{\N}
  \end{array}\]
  \caption{Built-in functions and their type schemes}
\end{figure}


%%
\section{Datafun by example}

%% Examples

\subsection{Transitive closure}

% what's a good example for parenthood? a dickens novel?
% how about Tolkien?
% Elrond - Arwen
% Arathorn - Aragorn
% Arwen + Aragorn - ???
%
% Melian - Luthien - ???

\subsubsection{Transitive closure with finite types}

\[\begin{array}{l}
%% FIXME: names
\mathbf{data}~\ms{Person} =
\ms{E\ddot{a}rendil} ~|~ \ms{Elrond} ~|~ \ms{Arwen}\\
\ms{parent},~\ms{ancestor} : \Set{(\ms{Person} \x \ms{Person})}\\
\ms{parent} = \{(\ms{E\ddot{a}rendil}, \ms{Elrond}),
(\ms{Elrond}, \ms{Arwen})\}\\
\ms{ancestor} = \fix{S} \ms{parent} \vee
\setfor{(a,c)}{(a,b) \in \ms{parent}, (b,c) \in S}\\
\end{array}\]

%% \begin{verbatim}
%% type person = Elrond | Arwen | Eldarion
%% parent, ancestor : set (person * person)
%% parent = {(Elrond, Arwen), (Arwen, Eldarion)}
%% fix ancestor = parent lub
%%                {(a,c) | (a,b) in parent
%%                       , (=b,c) in ancestor}
%% \end{verbatim}

\subsubsection{Transitive closure with an upper bound}

If you know the type over which you are taking your transitive closure is
finite, this suffices. But the more general way to take a fixed-point is to give
an upper bound which you know the desired answer will not exceed. For this we
write $(\fixle{x}{e_\top} e)$

\[\begin{array}{l}
\ms{persons} ~:~ \Set{\Str}\\
\ms{persons} = \{\texttt{"e\"arendil"}, \texttt{"elrond"}, \texttt{"arwen"}\}\\
\ms{parent}, \ms{ancestor} ~:~ \Set{(\Str \x \Str)}\\
\ms{parent} = \{(\texttt{"e\"arendil"}, \texttt{"elrond"}),
(\texttt{"elrond"}, \texttt{"arwen"})\}\\
\ms{ancestor} = \fixle{S}{\setfor{(a,b)}{a \in \ms{person}, b \in \ms{person}}}
\\
\hspace{4.87em}\ms{parent} \vee
\setfor{(a,c)}{(a,b) \in \ms{parent}, (b,c) \in S}
\end{array}\]

\subsubsection{Generic transitive closure with an upper bound}

For any eqtype $\eq{A}$, we may write:
\[\begin{array}{l}
\ms{trans} ~:~
\Set{\eq{A}} \mto \Set{(\eq{A} \x \eq{A})} \mto \Set{(\eq{A} \x \eq{A})}
\vspace{0.3em}\\
\ms{trans}\ V\ E = \ms{fix}~ S \le \setfor{(a,b)}{a\in V, b \in V}
\\
\hspace{5.35em}\ms{is}~ E \vee \setfor{(a,c)}{(a,b) \in E, (b,c) \in S}
\end{array}\]

\subsection{CYK parsing}

\[\begin{array}{l}
\mathbf{type}~\ms{Sym} = \Str\\
\mathbf{data}~\ms{Rule} = \ms{String}~\Str ~|~ \ms{Cat}~\ms{Sym}~\ms{Sym}\\
\mathbf{type}~\ms{Grammar} = \Map{\ms{Sym}}{(\Set{\ms{Rule}})}
\end{array}\]


\section{Semantics}

\section{Implementation}
We have built a proof-of-concept implementation of Datafun in Racket
\todo{CITE}. In addition to core Datafun, it supports pattern-matching, variant
types, record types, subtyping, antitone functions, and unbounded (potentially
nonterminating) fixed points. It performs no optimizations whatsoever.

\todo{LINK}

%% not sure how many sections to split this up into.
\section{Tradeoffs, limitations, and design decisions}
\section{Related and future work}

%% ACKNOWLEDGMENTS
\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}
\bibliography{datafun}

%% \appendix
%% \section{Appendix Title}

%% This is the text of the appendix, if you need one.


\end{document}
