\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% numbers       To obtain numeric citation style instead of author/year.

\usepackage{rntz}

\renewcommand{\pipe}{\mathrel{\mid}} %overrides rntz.sty
\newcommand{\uto}{\to}
\newcommand{\rn}[1]{\mathsz{8pt}{\ms{#1}}} %for inference rule names
\def\arraystretch{1.1}                     %a little more spacing, please

%% taken from the source for Dunfield & Krishnaswami's paper "Complete and Easy
%% Bidirectional Typechecking for Higher-Rank Polymorphism"
\newdimen\zzfontsz
\newcommand{\fontsz}[2]{\zzfontsz=#1%
{\fontsize{\zzfontsz}{1.2\zzfontsz}\selectfont{#2}}}
\newcommand{\mathsz}[2]{\text{\fontsz{#1}{$#2$}}}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{ICFP '16}{Month d--d, 2016, City, ST, Country}
\copyrightyear{2016}
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
\copyrightdoi{nnnnnnn.nnnnnnn}

% Uncomment the publication rights you want to use.
%\publicationrights{transferred}
%\publicationrights{licensed}     % this is the default
%\publicationrights{author-pays}

% These are ignored unless 'preprint' option specified.
\titlebanner{preprint}
\preprintfooter{Datafun: a Functional Datalog (PREPRINT)}

\title{Datafun: a Functional Datalog}
%% \subtitle{}

%% \title{Datafun}
%% \subtitle{A Functional Datalog}

%% \title{Datafun}
%% \subtitle{or, Datalog with datatypes}

%% \title{Datalog with Datatypes}
%% \subtitle{Toward a functional language of finite sets}

\authorinfo{Michael Arntzenius\and Neelakantan R. Krishnaswami}
           {University of Birmingham}
           {Email2/3}

\maketitle


\begin{abstract}
This is the text of the abstract.
\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore,
% you may leave them out
\terms
term1, term2

\keywords
keyword1, keyword2


\section{Introduction}

%% Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nec vero alia sunt
%% quaerenda contra Carneadeam illam sententiam. Cum ageremus, inquit, vitae beatum
%% et eundem supremum diem, scribebamus haec. Quid sequatur, quid repugnet, vident.

%% Minime id quidem, inquam, alienum, multumque ad ea, quae quaerimus, explicatio
%% tua ista profecerit. Qua ex cognitione facilior facta est investigatio rerum
%% occultissimarum. Quis animo aequo videt eum, quem inpure ac flagitiose putet
%% vivere? Primum quid tu dicis breve? Ita enim vivunt quidam, ut eorum vita
%% refellatur oratio.

\TODO

\paragraph{Contributions}
\begin{itemize}
\item We describe Datafun, a typed language capturing the expressive power of
  Datalog and extending it to support higher-order functional programming.
  Datafun's key feature is to \emph{track monotonicity with types}.

\item We present examples illustrating the expressive power of Datafun,
  including relational-algebra-style operations, transitive closure, CYK
  parsing, and dataflow analysis.

\item We identify the semantic structures underpinning Datalog, and use this to
  give a denotational semantics for Datafun in terms of a pair of adjunctions
  between \ms{Set}, \ms{Poset}, and the category of join-semilattices with a
  least element.

\item We have a prototype implementation of Datafun in Racket. \todo{(CITE)}
\end{itemize}

%% Contributions (as summarized by Michael):
% - Datafun, like Datalog but functional
% - examples, incl. both datalog examples & things datalog canâ€™t do
% - key ingredient is monotonicity; ``found'' semantics by analyzing
%   datalog: two adjunctions, three categories
% - prototype implementation

%% Contributions (as written by Neel):

% - We describe Datafun, a type theory for a language capturing the expressive
%   power of Datalog and extends it to both relax the constructor term
%   restriction and to support higher-order functional programming.

% - We give a variety of examples that illustrate the expressive power of
%   Datafun, such as CYK parsing, dataflow analysis, and transitive closure on
%   graphs, etc. Many of these examples are traditional examples of Datalog,
%   but we are also able to support things like first-class relations (eg,
%   generic transitive closure) and higher-order functions (example using
%   monotonicity and HO?). (doing a fix-point code analysis / parsing something
%   & dispatching on result?)

% - We identify the semantic structures underpinning Datalog, and use this to
%   give a denotational semantics for Datafun in terms of a pair of adjunctions
%   between Set, Poset, and the category of semilattices with finitary joins.

% - We have a prototype implementation of Datafun in Racket. 


%% FIGURE: CORE SYNTAX
\begin{figure}
  \[\begin{array}{ccl}
    %% types
    A, B     &\bnfeq& \bool \pipe \N \pipe \str \pipe \Set{A}
                      \pipe \Map{A}{B}
    \\
    \textsf{types} && A + B \pipe A \x B \pipe A \uto B \pipe A \mto B
    \vspace{0.5em}\\
    %% usl types
    L, M         &\bnfeq& \bool \pipe \N \pipe \Set{A} \pipe \Map{A}{L}
    \\
    \textsf{usl types} && L \x M \pipe A \uto L \pipe A \mto L
    \vspace{0.5em}\\
    %% equality types
    \eq{A}, \eq{B} &\bnfeq& \bool \pipe \N \pipe \str \pipe \Set{\eq{A}}
                            \pipe \Map{\eq{A}}{\eq{B}}
    \\
    \textsf{eqtypes} && \eq{A} + \eq{B} \pipe \eq{A} \x \eq{B}
    \vspace{0.5em}\\
    %% finite equality types
    \fineq{A},\fineq{B}
    &\bnfeq& \bool \pipe \Set{\fineq{A}}
       \pipe \Map{\fineq{A}}{\fineq{B}}
       \pipe \fineq{A} + \fineq{B} \pipe \fineq{A} \x \fineq{B}\\
    \textsf{finite eqtypes}
    \vspace{0.5em}\\
    %% usl (finite) eqtypes
    %% \eq{L}, \eq{M} &\defeq& \textsf{usl types}~\cap~\textsf{eqtypes}
    %% \vspace{0.5em}\\
    %% \fineq{L}, \fineq{M}
    %% &\defeq& \textsf{usl types}~\cap~\textsf{finite eqtypes}
    %% \vspace{0.5em}\\
    %% contexts
    \GD &\bnfeq& \cdot \pipe \GD, x\of A\\
    \GG &\bnfeq& \cdot \pipe \GG{}, \m{x}\of A\\
    \textsf{contexts}
    \vspace{0.3em}\\
    %% expressions
    e &\bnfeq& x \pipe \m{x} \pipe \fn\bind{x} e \pipe \fn\bind{\m{x}} e
    \pipe e\;e\\
    \textsf{terms}
    && (e,e) \pipe \pi_i\;e \pipe \ms{in}_i\;e \pipe e = e\\
    && \case{e}{x}{e}{x}{e}\\
    && \case{e}{\m{x}}{e}{\m{x}}{e}\\
    && \ms{true} \pipe \ms{false} \pipe \ifthen{e}{e}{e}\\
    && \singleset{e} \pipe \singlemap{e}{e}
       \pipe \unit \pipe e \vee e \pipe \letin{x}{e}{e}\\
    && \fix{\m{x}}{e} \pipe \fixle{\m{x}}{e}{e}
  \end{array}\]
  \caption{Syntax of core Datafun}
  \label{fig:syntax}
\end{figure}


\section{Intuition}

We give the core syntax of Datafun in Figure \ref{fig:syntax}. Datafun is a
simply-typed $\lambda$-calculus extended in four major ways:

\begin{enumerate}
\item We add a type of finite sets $\Set{A}$. We use finite sets to represent
  Datalog predicates; one might also think of them as tables or views in a
  database setting. We also include finite maps $\Map{A}{B}$, as they are useful
  for some examples.

  \todo{TODO: make clearer bit about what we use finite sets for. don't rely on
    Datalog so heavily.}

\item We add a type of \emph{monotone functions}, $A \mto B$. Consequently
  Datafun has two flavors of variable, \emph{ordinary} and \emph{monotone}.
  Ordinary functions introduce ordinary variables; monotone functions introduce
  monotone variables, which we write in \textbf{bold}.

  In order for ``monotone'' to have meaning, our types are implicitly partially
  ordered. \todo{Discuss orderings.} Sets are ordered by inclusion: $a \le b :
  \Set{A}$ iff $a \subseteq b$. Maps are ordered both by inclusion and
  pointwise.

\item We add a \emph{monotone least fixed point} term, $(\fix{\m{x}}{e})$. This
  allows us to express Datalog-style recursion.

  \todo{TODO: Explain without as much reference to Datalog.}

  To ensure termination, the type at which this fixed-point is taken must be
  \emph{finite} (this corresponds directly to Datalog's requirement that
  predicates be finite). To ensure uniqueness of the least fixed point, the type
  must have a \emph{least element}.

\item Generalizing the empty set $\emptyset$ and the union operator $\cup$, we
  identify a subset of types that have a \emph{least element} $\unit$ and
  support a \emph{least-upper bound} operator $\vee$. We call these \emph{usl
    types}\footnote{\emph{Usl} stands for ``unitary semilattice'', meaning that
    the partial orderings on these types form join-semilattices with a unit
    (least element).}, and denote them by the metavariables $L,M$.

  Usl types are the ``glue'' of Datafun; they do not serve one single purpose,
  but simplify the language by satisfying many small ones at once.

  First, usl types provide a natural comprehension-style eliminator for sets:
  given $e : \Set{A}$ we may write $\letin{x}{e}{e'}$ for the least-upper-bound,
  over all elements $x \in e$, of $e'$, as long as $e' : L$ is of usl type.
  Notably, if $e'$ is itself of set type, this provides a monadic bind
  operation. \todo{explain testing for set membership?}

  Second, we restrict fixed-points $(\fix{\m{x}}{e})$ to usl types, which
  guarantees that we take

  \todo{Explain how usl types + monotone fixed-points account for Datalog-style
    mutual recursion.}

  \todo{Rewrite this to be clearer.}

\end{enumerate}


%% FIGURE: SYNTAX SUGAR
\begin{figure}
  \[\begin{array}{lccl}
  %% expressions
  \textsf{terms} &
  e &\bnfeq& ... \pipe e \isin e \pipe \setfor{e}{\mc{L}}
             \pipe \forin{\mc{L}}{e}\\
  &&& \mathcal{C}[\;e]^* \pipe \rawcase{e}{[{p} \to {e}]^*}\\
  &&& \ms{let}~ [x = e]^* ~\ms{in}~ e
  \vspace{0.5em}\\
  %% patterns
  \textsf{patterns} &
  p &\bnfeq& \pwild \pipe x \pipe (p,p)
             \pipe \ms{true} \pipe \ms{false} \pipe \mathcal{C}[\;p]^*
  \vspace{0.5em}\\
  \textsf{constructors} & \mathcal{C} && \text{are abstract identifiers}
  \vspace{0.5em}\\
  %% loop clauses
  \textsf{loops} &
  \mc{L} &\bnfeq& \mc{L}, \mc{L} \pipe p \in e \pipe e
  \end{array}\]

  %% the desugaring syntax-expansion itself
  \begin{eqnarray*}
    e_1 \isin e_2            &\expandsto& \forin{x \in e_2} e_1 = x\\
    \setfor{e}{\mc{L}}       &\expandsto& \forin{\mc{L}}{\{e\}}\\
    \forin{\mc{L}_1,\mc{L}_2}{e}
    &\expandsto& \forin{\mc{L}_1}{\forin{\mc{L}_2}{e}}\\
    \forin{p\in e_1}{e_2}
    &\expandsto& \letin{x}{e_1}{\rawcase{x}{p \to e_2;\,\pwild \to \unit}}\\
    \forin{e_1}{e_2} &\expandsto& \ifthen{e_1}{e_2}{\unit}%% \\
    %% \ms{let}~x = e_1 ~\ms{in}~ e_2
    %% &\expandsto& (\fn\bind{x} e_2)\; e_1\\
    %% \ms{let}~[x_i = e_i]^* ~\ms{in}~ e
    %% &\expandsto& [\ms{let}~x_i = e_i~\ms{in}]^* e\\
    %% \rawcase{e}{[p \to e]^*} &\expandsto& \text{(omitted, see \todo{CITE})}
  \end{eqnarray*}
  \caption{Syntax sugar}
  \label{fig:sugar}
\end{figure}

\begin{figure}
  \[\begin{array}{cll}
  \le &\of& \eq{A} \uto \eq{A} \mto \bool\\
  \fname{keys}     &:& \Map{A}{B} \mto \Set{A}\\
  \fname{entries}  &:& \Map{A}{B} \uto \Set{A \x B}\\
  \fname{tabulate} &:& \Set{A} \mto (A \to B) \mto \Map{A}{B}\\
  %% \fname{getWith}  &:& \Map{\eq{A}}{B} \mto \eq{A} \uto (B \mto L) \mto L\\
  \fname{get}      &:& \Map{\eq{A}}{L} \mto \eq{A} \uto L\\
  %% \fname{substrings} &\of& \ms{Str} \to \Set{\ms{Str}}\\
  %% \fname{size}     &:& \Set{\eq{A}} \mto \N\\
  \fname{range}    &:& \N \uto \N \mto \Set{\N}\\
  \fname{length}   &:& \str \uto \N\\
  \fname{substring} &:& \str \uto \N \uto \N \uto \str
  \end{array}\]
  \caption{Built-in functions and their type schemes}
\end{figure}


%% FIGURE: Typing rules
\begin{figure*}
  \boxed{\ensuremath{\mathsz{10pt}{\J{\Delta}{\Gamma}{e}{A}}}}
  \begin{mathpar}
    \infer[\rn{var}]{\J{\GD}{\GG}{x}{A}}{x\of A \in \GD}
    \and
    \infer[\rn{var^+}]{\J{\GD}{\GG}{\m{x}}{A}}{\m{x} \of A \in \GG}
    %% function rules
    \and
    \infer[\fn]{\J{\GD}{\GG}{\fn\bind{x} e}{A \uto B}}{
      \J{\GD,x\of A}{\GG}{e}{B}}
    \and
    \infer[\monofn]{\J{\GD}{\GG}{\fn\bind{\m{x}} e}{A \mto B}}{
      \J{\GD}{\GG,\m{x} \of A}{e}{B}}
    \and
    \infer[\rn{app}]{\J{\GD}{\GG}{e_1\;e_2}{B}}{
      \J{\GD}{\GG}{e_1}{A \uto B} &
      \J{\GD}{\cdot}{e_2}{A}}
    \and
    \infer[\rn{app^+}]{\J{\GD}{\GG}{e_1\;e_2}{B}}{
      \J{\GD}{\GG}{e_1}{A \mto B} &
      \J{\GD}{\GG}{e_2}{A}}
    %% product & sum rules
    \and
    \infer[\rn{pair}]{\J{\GD}{\GG}{(e_1,e_2)}{A_1 \x A_2}}{
      \J{\GD}{\GG}{e_i}{A_i}}
    \and
    \infer[\rn{\pi}]{\J{\GD}{\GG}{\pi_i\;e}{A_i}}{\J{\GD}{\GG}{e}{A_1 \x A_2}}
    \and
    \infer[\rn{in}]{\J{\GD}{\GG}{\ms{in}_i\;e}{A_1 + A_2}}{\J{\GD}{\GG}{e}{A_i}}
    \and
    \infer[\rn{case}]{\J{\GD}{\GG}{\case{e}{x}{e_1}{x}{e_2}}{C}}{
      \J{\GD}{\cdot}{e}{A_1 + A_2} &
      \J{\GD,x\of A_i}{\GG}{e_i}{C}}
    \and
    \infer[\rn{case^+}]{\J{\GD}{\GG}{\case{e}{\m{x}}{e_1}{\m{x}}{e_2}}{C}}{
      \J{\GD}{\GG}{e}{A_1 + A_2} &
      \J{\GD}{\GG,\m{x}\of A_i}{e_i}{C}}
    %% boolean rules
    \and
    \infer[\rn{=}]{\J{\GD}{\GG}{e_1 = e_2}{\bool}}{\J{\GD}{\GG}{e_i}{\eq{A}}}
    \and
    \infer[\rn{true}]{\J{\GD}{\GG}{\ms{true}}{\bool}}{}
    \and
    \infer[\rn{false}]{\J{\GD}{\GG}{\ms{false}}{\bool}}{}
    \and
    \infer[\rn{if}]{\J{\GD}{\GG}{\ifthen{e}{e_1}{e_2}}{A}}{
      \J{\GD}{\cdot}{e}{\bool} &
      \J{\GD}{\GG}{e_i}{A}}
    \and
    \infer[\rn{if^+}]{\J{\GD}{\GG}{\ifthen{e}{e_1}{\unit}}{L}}{
      \J{\GD}{\GG}{e}{\bool} &
      \J{\GD}{\GG}{e_1}{L}}
    %% set & semilattice rules
    \and
    \infer[\rn{\{\}}]{\J{\GD}{\GG}{\{e\}}{\Set{A}}}{\J{\GD}{\cdot}{e}{A}}
    \and
    \infer[\rn{\{:\}}]{\J{\GD}{\GG}{\singlemap{e_1}{e_2}}{\Map{A}{B}}}{
      \J{\GD}{\cdot}{e_1}{A} &
      \J{\GD}{\GG}{e_2}{B}}
    \and
    \infer[\unit]{\J{\GD}{\GG}{\unit}{L}}{}
    \and
    \infer[\rn{\vee}]{\J{\GD}{\GG}{e_1 \vee e_2}{L}}{\J{\GD}{\GG}{e_i}{L}}
    \and
    \infer[\rn{\bigvee}]{\J{\GD}{\GG}{\letin{x}{e_1}{e_2}}{L}}{
      \J{\GD}{\GG}{e_1}{\Set{A}} &
      \J{\GD,x\of A}{\GG}{e_2}{L}}
    \\
    \infer[\rn{fix}]{\J{\GD}{\GG}{\fix{\m{x}}{e}}{\fineq{L}}}{
      \J{\GD}{\GG,\m{x}\of L}{e}{\fineq{L}}}
    \and
    \infer[\rn{fix_{\le}}]{\J{\GD}{\GG}{\fixle{\m{x}}{e_1}{e_2}}{\eq{L}}}{
      \J{\GD}{\GG}{e_1}{\eq{L}} &
      \J{\GD}{\GG,\m{x} \of \eq{L}}{e_2}{\eq{L}}}
  \end{mathpar}

  \caption{Typing rules for core Datafun}
\end{figure*}


%%
\pagebreak
\section{Examples}

For purposes of these examples, we use a simple Haskell-like syntax for
top-level type and function definitions. We also permit ourselves
pattern-matching\todo{(CITE)} and some other syntax sugar, defined in Figure
\ref{fig:sugar}.

\todo{TODO: mention \& cite monadic query syntax}

\todo{\begin{itemize}
\item composition of relations?
\item \texttt{make}-style topological sort?
\item SQL-style examples?
\item translating relational algebra into datafun?
\end{itemize}}

%% Examples

\subsection{Filtering, mapping, and cross products}

\TODO

\subsection{Transitive closure}

Consider the following Datalog program:
\begin{verbatim}
parent(earendil, elrond).
parent(elrond, arwen).
ancestor(X, Y) :- parent(X, Y).
ancestor(X, Z) :- ancestor(X, Y), ancestor(Y, Z).
\end{verbatim}

%% already shows how datalog is not just a restriction of prolog: in datalog
%% this actually works, while in prolog, it suffers from infinite loops.

In Datafun, we may write this as:

\[\begin{array}{l}
\mathbf{data}~\ms{person} =
\ctor{E\"arendil} ~|~ \ctor{Elrond} ~|~ \ctor{Arwen}\\
\fname{parent},~\ms{ancestor} ~:~ \Set{\ms{person} \x \ms{person}}\\
\ms{parent} =
\{(\ctor{E\"arendil}, \ctor{Elrond}), (\ctor{Elrond}, \ctor{Arwen})\}\\
\ms{ancestor} = \fix{\m{X}} \ms{parent} \vee
\setfor{(a,c)}{(a,b) \in \m{X}, (b,c) \in \m{X}}\\
\end{array}\]

\subsubsection{Transitive closure with an upper bound}

If you know the type over which you are taking your transitive closure is
finite, this suffices. But the more general way to take a fixed-point is to give
an upper bound which you know the desired answer will not exceed. For this we
write $(\fixle{\m{x}}{e_\top} e)$

\[\begin{array}{l}
\ms{persons} ~:~ \Set{\str}\\
\ms{persons} = \{\texttt{"e\"arendil"}, \texttt{"elrond"}, \texttt{"arwen"}\}\\
\ms{parent}, \ms{ancestor} ~:~ \Set{\str \x \str}\\
\ms{parent} = \{(\texttt{"e\"arendil"}, \texttt{"elrond"}),
(\texttt{"elrond"}, \texttt{"arwen"})\}\\
\ms{ancestor} = \fixle{\m{X}}{%
  \setfor{(a,b)}{a \in \ms{person}, b \in \ms{person}}}
\\
\hspace{4.87em}\ms{parent} \vee
\setfor{(a,c)}{(a,b) \in \m{X}, (b,c) \in \m{X}}
\end{array}\]

\subsubsection{Generic transitive closure}

For any finite eqtype $\fineq{A}$, we may write:

\[\begin{array}{l}
\ms{trans} ~:~ \Set{\fineq{A} \x \fineq{A}} \mto \Set{\fineq{A} \x \fineq{A}}
\vspace{0.3em}\\
%% \ms{trans}\ E = \fix{X} E \vee \setfor{(a,c)}{(a,b) \in E, (b,c) \in X}
\ms{trans}\ \m{E} = \fix{\m{X}} \m{E} \vee %
\setfor{(a,c)}{(a,b) \in \m{X}, (b,c) \in \m{X}}
\end{array}\]

\TODO (and similarly for any eqtype $\eq{A}$ by using a bounded fixed-point)

For any eqtype $\eq{A}$, we may write:
\[\begin{array}{l}
\ms{trans} ~:~
\Set{\eq{A}} \mto \Set{\eq{A} \x \eq{A}} \mto \Set{\eq{A} \x \eq{A}}
\vspace{0.3em}\\
\ms{trans}\ \m{V}\ \m{E} = %
\ms{fix}~ \m{S} \le \setfor{(a,b)}{a\in \m{V}, b \in \m{V}}\\
\hspace{5.35em}\ms{is}~ \m{E} \vee %
\setfor{(a,c)}{(a,b) \in \m{E}, (b,c) \in \m{S}}\\
%% \ms{trans}\ V\ E = \fixle{S}{V \x V} E \vee (S \bullet S)
\end{array}\]

\TODO This already shows how we go beyond Datalog's .

\subsection{CYK parsing}

\[\begin{array}{l}
\mathbf{type}~\ms{sym} = \str\\
\mathbf{data}~\ms{rule} = \ctor{String}~\str ~|~ \ctor{Cat}~\ms{sym}~\ms{sym}\\
\mathbf{type}~\ms{grammar} = \Set{\ms{sym} \x \ms{rule}}\\
\mathbf{type}~\ms{fact} = \ms{sym} \x \N \x \N\\
\fname{parse} ~:~ \str \uto \ms{grammar} \mto \Set{\ms{sym}}\\
\fname{iter} ~:~ \str \uto \ms{grammar} \mto \Set{\ms{fact}}
\mto \Set{\ms{fact}}\\
\fname{parse}\;w\;\m{g} =\\
\hspace{1em} \ms{let}~ n = \ms{length}\;w\\
\hspace{2.375em}\m{u} =
  \setfor{(a,i,j)}{(a,\pwild) \in \m{g}, i \in \ms{range}\;0\;n,
  j\in\fname{range}\;i\;n}\\
\hspace{1em}\ms{in}~\setfor{a}{(a, 0, n) \in %
  \fixle{\m{X}}{\m{u}} \ms{iter}\;w\;\m{g}\;\m{X}}\\
\fname{iter}\;w\;\m{g}\;\m{X} =\\
\hspace{1em}\phantom{\vee~}\setfor{(a,i,k)}{(a, \ctor{Cat}~b~c) \in \m{g},
  (b,i,j) \in \m{X}, (c,j,k) \in \m{X}}\\
\hspace{1em}\vee~ \{(a,i,i+\fname{length}\;s)\\
\hspace{2.1em}|~ (a, \ctor{String}~s) \in \m{g},
i \in \fname{range}\;0\;(n-\fname{length}\;s),\\
\hspace{2.2em}\phantom{|~} s = \fname{substring}\;w\;i\;(i+\ms{length}\;s)\}
\end{array}\]

\TODO Since Datalog provides no way to represent a \emph{grammar} as a piece of
data (because it's compound, not an atom), there is simply no way in Datalog
proper to express a generic CYK parser. This demonstrates the benefits of moving
to a functional language.

\TODO Moreover, Datalog's strategy for proving termination involves a
constructor restriction to ensure all relations are finite. Primitives such as
\ms{range} and \ms{substring} violate this restriction (as relations, they are
infinite); it is not immediately obvious that Datalog programs extended with
these primitives remain terminating. Our use of bounded fixed-points to
guarantee termination is robust under such extensions; as long as no primitive
partial functions are introduced, Datafun programs always terminate.


\section{Typing rules}

\section{Semantics}

\section{Implementation}
We have built a proof-of-concept implementation of Datafun in Racket
\todo{CITE}. In addition to core Datafun, it supports pattern-matching, variant
types, record types, subtyping, antitone functions, and unbounded (potentially
nonterminating) fixed points. It performs no optimizations whatsoever.

\todo{LINK}

%% not sure how many sections to split this up into.
\section{Tradeoffs, limitations, and design decisions}

\paragraph{Finite and bounded fixed-points} \TODO Discuss
Datalog's constructor restriction (name?), not being sure how to encode it in a
type theory, its disadvantages, and the disadvantages of our approaches ---
finite \& bounded fixed-points.

bounded fixed-points strictly more general than finitary-type fixed-points, but
at possible runtime cost, but finite types very restrictive in practice

\TODO In particular, could bounded fix-points have adverse performance
implications?

\paragraph{Termination} \TODO nontermination and declarativeness.

For example, one powerful optimization technique is \emph{loop reordering} (in
SQL terminology, \emph{join reordering}), that is, taking advantage of the
equation
\begin{eqnarray*}
  \forin{x \in e_1} \forin{y \in e_2} e
  &=& \forin{y \in e_2} \forin{x \in e_1} e
\end{eqnarray*}
when $x,y \notin \ms{FV}(e_1) \cup \ms{FV}(e_2)$. (\TODO Explain why join
reordering is powerful). But this equation does not always hold in the presence
of nontermination; for example, if $e_1 = \unit$ and $e_2$ diverges. \TODO
finish up

\paragraph{Type inference} Typechecking needs to distinguish between ordinary
and monotone $\lambda$, application, \ms{case}, \ms{let}, and \ms{if}. In our
implementation we solve this in two ways:
\begin{enumerate}
\item Bidirectional type inference \todo{CITE} determines whether $\fn$s and
  applications are ordinary or monotone.
\item For $\ms{if}$, $\ms{case}$, and $\ms{let}$, the programmer annotates which
  form is intended; for example, $(\ifthen{e}{e_1}{\unit})$ is written
  (\texttt{when e then e1}) to indicate the rule $\ms{if}^+$ applies.
\end{enumerate}

It remains an open question how much annotation is necessary. See
Section \ref{sec:futurework}, \emph{Related and future work}.

\paragraph{Lexical types} (\todo{TODO})
\begin{itemize}
\item Pro: allow expressing many things more generally, for example, map lookup
\item Con: have no good general monotone elimination rule
\item Con: complicate the type theory
\end{itemize}

\section{Related and future work}
\label{sec:futurework}

\paragraph{Optimization}
\begin{itemize}
\item \TODO the datalog literature
\end{itemize}

\paragraph{Polymorphism}
\begin{itemize}
\item \TODO quantification over different classes of type variable (ordinary,
  equality, lattice); amounts to a typeclass system, so this is not new work.
\item \TODO tone polymorphism and why you need it for principal types; e.g.
  what is the type of $\fn\bind{f}\fn\bind{x} f\;x$?
\end{itemize}

\paragraph{Type inference} blah

\TODO Ref Dunfield \& Krishnaswami, higher-order bidirectional type inference.

\todo{REWRITE} We speculate that bidirectional inference could be replaced by a
Damas-Milner \todo{CITE} style algorithm, which infers a principal type for any
term without any annotation at all, \emph{if} we add polymorphism,
tone-polymorphism, and subtyping---so that, for example, $\fn\bind{f}\fn\bind{x}
f\;x$ can be assigned the principal type
$\forall\bind{o\of\ms{tone}}\forall\bind{\alpha,\beta \of \ms{type}} (\alpha
\overset{o}\to \beta) \mto (\alpha \overset{o}\to \beta)$, where
$\overset{o}\to$ indicates a function of tone $o$; a tone may be empty (for an
ordinary function) or ${+}$ for a monotone function.

\todo{does Neel think this is a reasonable conjecture?}

%% ACKNOWLEDGMENTS
\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}
\bibliography{datafun}

%% \appendix
%% \section{Appendix Title}

%% This is the text of the appendix, if you need one.


\end{document}
