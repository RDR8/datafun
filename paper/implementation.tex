\section{Implementation}
We have built a proof-of-concept implementation of Datafun in Racket, available
at \texttt{[link omitted for double-blind review]}. In addition to core Datafun,
it supports pattern-matching, variant types, record types, dictionaries,
subtyping, antitone functions, and unbounded (potentially nonterminating) fixed
points. It performs no optimizations whatsoever.

\paragraph{Type inference}
As a practical matter, type-checking needs to distinguish between ordinary and
monotone $\lambda$, application, \ms{case}, \ms{let}, and \ms{if}. In our
implementation we solve this in two ways:
\begin{enumerate}
\item Bidirectional type inference \todo{CITE} determines whether $\fn$s and
  applications are ordinary or monotone.
\item For $\ms{if}$, $\ms{case}$, and $\ms{let}$, the programmer annotates which
  form is intended; for example, $(\ifthen{e}{e_1}{\unit})$ is written
  (\texttt{when e then e1}) to indicate the rule $\ms{if}^+$ applies.
\end{enumerate}

It remains an open question how much annotation is necessary. We speculate that
bidirectional inference could be replaced by a Damas-Milner \todo{CITE} style
algorithm, which infers a principal type for any term without any annotation at
all, \emph{if} we add polymorphism, tone-polymorphism, and subtyping---so that,
for example, $\fn\bind{f}\fn\bind{x} f\;x$ can be assigned the principal type
$\forall\bind{o\of\ms{tone}}\forall\bind{\alpha,\beta \of \ms{type}} (\alpha
\overset{o}\to \beta) \mto (\alpha \overset{o}\to \beta)$, where
$\overset{o}\to$ indicates a function of tone $o$; a tone may be empty (for an
ordinary function) or ${+}$ for a monotone function.

%% \todo{explain subtyping?}
%% \todo{explain antitonicity?}
%% \todo{explain ordering on dictionaries?}
