\section{Implementation}
We have built a proof-of-concept implementation of Datafun in Racket
\todo{CITE}. In addition to core Datafun, it supports
pattern-matching, variant types, record types, dictionaries,
subtyping, antitone functions, and unbounded (potentially
nonterminating) fixed points. It performs no optimizations whatsoever.

\todo{explain subtyping?}
\todo{explain antitonicity?}
\todo{explain ordering on dictionaries?}

\paragraph{Type inference} Typechecking needs to distinguish between ordinary
and monotone $\lambda$, application, \ms{case}, \ms{let}, and \ms{if}. In our
implementation we solve this in two ways:
\begin{enumerate}
\item Bidirectional type inference \todo{CITE} determines whether $\fn$s and
  applications are ordinary or monotone.
\item For $\ms{if}$, $\ms{case}$, and $\ms{let}$, the programmer annotates which
  form is intended; for example, $(\ifthen{e}{e_1}{\unit})$ is written
  (\texttt{when e then e1}) to indicate the rule $\ms{if}^+$ applies.
\end{enumerate}

It remains an open question how much annotation is necessary. See
Section \ref{sec:futurework}, \emph{Related and future work}.

\todo{LINK TO GITHUB (except not for the peer review version)}
