* Datafun

Datafun is a *pure & total* functional language for expressing *fixed points* of
*monotone maps* on *semilattices satisfying an ascending chain condition*.

Example: *Static analyses*

* Static analysis

  1   x := 0
  2   t := 3            # t is constant                     <- IN GREEN
  3   while true
  4     s := if x = 1 then 7 else 4 + t     # always 7      <- IN RED
  5     x := x + 1
  6     print s         # print 7                           <- IN BLUE

This is equivalent to:

  while true
    print 7

# OPTION 1:
# You don't need to understand this program yet!
# But I'm going to use static analysis to prove that on the BLUE line, #7,
# `print s' can be replaced by `print 7'.

# OPTION 2:
# Observe the green line. This is the only line that assigns to `three'. So
# `three' is always 3.

# Now, observe the red line. This is the only line that assigns to `seven', and
# given that `three' is a constant, it always produces the value 7.

# Therefore, this program can be optimized into the one below it.

# I want to show you just one necessary part of this optimization: determining
# that `seven' has the value `7' at the BLUE line, so `print seven' can turn
# into `print 7'.

* Static analysis

# The analysis I'm going to use is a form of constant propagation.

# For each variable, at each line, we'll track whether it is unassigned,
# constant, or may have multiple values. We'll determine these facts using a
# form of abstract interpretation: (BLAH)

  1   x := 0                                x = 0
  2   t := 3                                x = 0, t = 3
  3   while true                            x = 0, t = 3
  4     s := if x = 1 then 7 else 4 + t     x = 0, t = 3, y = 7
  5     x <- x + 1                          x = 1, t = 3, y = 7
  6     print s                             x = 1, t = 3, y = 7

# Ah, but now the program loops! It jumps from line 6 to line 3!

  1   x := 0                                x = 0
  2   t := 3                                x = 0, t = 3
  3   while true                            x = ⊤, t = 3            <- IN RED
  4     s := if x = 1 then 7 else 4 + t     x = 0, t = 3, y = 7     <- IN GREY
  5     x <- x + 1                          x = 1, t = 3, y = 7     <- IN GREY
  6     print s                             x = 1, t = 3, y = 7     <- IN GREY

# Now, observe that x might have multiple values: either 0, as it was assigned
# on line 1, or 1, which is the value that flowed in from line 6. We don't want
# to track all the values it could possibly have - in this program, that would
# be fruitless, because it takes on an endless number of values; it's an
# infinite loop. So our static analysis would never terminate.

# Instead, we mark it with the symbol ⊤, to indicate it might take on multiple
# values; you can think ⊤ as standing for "unknown".

# Now, see all those lines in grey? They need to be re-evaluated, because line 3
# flows into them! So let's do that.

  1   x := 0                                x = 0
  2   t := 3                                x = 0, t = 3
  3   while true                            x = ⊤, t = 3
  4     s := if x = 1 then 7 else 4 + t     x = ⊤, t = 3, s = 7
  5     x <- x + 1                          x = ⊤, t = 3, s = 7
  6     print s                             x = ⊤, t = 3, s = 7

# If it's either 1 or unknown, then it's unknown.
# And the process repeats for each line.

# Once we reach line 6, we could loop back again to line 3, but we wouldn't gain
# any new information: we've reached a fixed point. So now our static analysis
# is done, and let's look at line 6 - `print s'. As expected, `s' is constant
# with value `7'! So we can rewrite `print s' to `print 7'.

* Connecting to our definition

Semilattice: undefined < constant (with some value) < varying
# (TODO: DIAGRAM)
# (do I need to explain what a semilattice is?)

Monotonicity: Only *increases* allowed (undefined → constant → variable)

Fixed points: Keep going until nothing changes!

ACC: Can't keep going forever!

# Note about structural induction versus fixed points: the proof that this
# terminates depends on having an upper bound, but it's naturally defined as
# finding a fixed point, not as structural induction.

* What's expressible as a semilattice fixed point?

Surprisingly many things!

- Static analyses
- Shortest path
- CYK algorithm for parsing CFGs
- &c...
- *Every Datalog program*

* How do we express semilattice fixed points?

    fix (λx. ...)

Need to check:
1. *Function must be monotone*
2. on a semilattice satisfying ACC

* (no title)

TRACK MONOTONICITY WITH TYPES

* Types are posets

2          booleans            false < true
{A}        finite sets         by inclusion
A × B      pairs               pointwise
A → B      functions           pointwise, f ≤ g ↔ (∀x) f x ≤ g x
A →⁺ B     MONOTONE functions  pointwise

* Example: membership

mem : string → {string} →⁺ 2
mem x s = ∃(y ∈ s) x = y

* Discrete vs monotone

2 kinds of function: discrete or monotone
2 kinds of variable: discrete or monotone
2 typing contexts: Δ discrete, Γ monotone

Typing judgment:

    Δ;Γ ⊢ e : τ

* Typing rules

Δ;Γ ⊢ e₁ : A →⁺ B    Δ;Γ ⊢ e₂ : A
----------------------------------
      Δ;Γ ⊢ e₁ e₂ : B

# SHOW THIS FIRST ↑
# Apart from two contexts, this is perfectly ordinary

Δ;Γ ⊢ e₁ : A → B    Δ;ε ⊢ e₂ : A
---------------------------------
      Δ;Γ ⊢ e₁ e₂ : B

# But when we apply a discrete function, the argument gets an empty monotone
# context! Why is this?

* Typing rules: semilattices & sets

# Can we cut this?

    Δ;Γ ⊢ eᵢ : L
  -----------------
  Δ;Γ ⊢ e₁ ∨ e₂ : L

Δ;Γ ⊢ e₁ : {A}      Δ,x:A; Γ ⊢ e₂ : L
-------------------------------------
       Δ;Γ ⊢ ⋁(x ∈ e₁) e₂ : L

* Example program

    fix λself.
      edges
    ∪ {(x,z) | (x,y) ∈ self, (!y,z) ∈ self}


Datalog, for comparison:

    path(X,Y) :- edge(X,Y).
    path(X,Z) :- path(X,Y), path(Y,Z).
