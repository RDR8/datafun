\begin{figure}
  \[\begin{array}{ccl}
    %% expressions
    e,f,g
    &\bnfeq& ... \pipe \setlit{\vec{v}} \pipe \unit_L \pipe e \vee_L e \pipe \tforin{L}{x \in e} e\\
    \textsf{expressions}
    && \tfix{\fineq{L}}{x}{e} \pipe \tfixle{\eq{L}}{x}{e}{e}\\
    && \iter{\eq{A}}{e}{x}{e} \pipe \iterstep{\eq{A}}{e}{e}{x}{e}\\
    && \iterle{\eq{A}}{e}{e}{x}{e} \pipe \iterlestep{\eq{A}}{e}{e}{e}{x}{e}
    \vspace{0.5em}\\
    %% values
    v,u,w
    &\bnfeq& \fn\bind{x} e \pipe (v, v) \pipe \ms{in}_i\; v
    \pipe \ms{true} \pipe \ms{false} \pipe \setlit{\vec{v}}\\
    \textsf{values}
    \vspace{0.5em}\\
    %% contexts
    E
    &\bnfeq& \hole \pipe E\;e \pipe v\;E \pipe (E, e) \pipe (v, E) \pipe \ms{in}_i\;E
    \pipe \pi_i \; E\\
    \textsf{evaluation}
    && E \vee_L e \pipe v \vee_L E \pipe \tforin{L}{x \in E} e\\
    \textsf{contexts}
    && \ifthen{E}{e}{e}\\
    && \case{E}{x}{e}{x}{e}\\
    && \iter{\eq{A}}{E}{x}{e} \pipe \iterstep{\eq{A}}{v}{E}{x}{e}\\
    && \iterle{\eq{A}}{E}{e}{x}{e} \pipe \iterle{\eq{A}}{v}{E}{x}{e}\\
    && \iterlestep{\eq{A}}{v}{v}{E}{x}{e}
  \end{array}\]
  \caption{Operational semantics syntax}
  \label{fig:opsem-syntax}
\end{figure}

\begin{figure}
  
  \caption{Rules for $\step$}
  \label{fig:opsem-rules}
\end{figure}


\section{A na\"ive operational semantics}

We consider the denotational semantics to be primary in Datafun; as with
Datalog, any implementation technique is valid so long as it lines up with these
semantics. As a proof of concept, however, we present a simple call-by-value
operational semantics and show that it terminates.

In our operational semantics we:
\begin{enumerate}
\item Assume an elaboration step which subscripts all semilattice operations
  ($\unit$, $\vee$, $\bigvee$, and $\ms{fix}$) with their type.
\item Drop the distinction between discrete and monotone variables, and write
  $x,y$ for arbitrary variables.
\item Ignore the types $\N$ and $\str$. \todo{TODO: justify?}
\item Add \ms{iter} expressions, which occur as intermediate forms in the
  evaluation of \ms{fix}.
\item Classify some expressions $e$ as values $v$, and add a value-form
  $\setlit{\vec{v}}$ for finite sets.
\end{enumerate}
We list the additional syntax in Figure \ref{fig:opsem-syntax}.

We use a small-step operational semantics using \emph{evaluation contexts} $E$
after the style of \citet{reduction-contexts} to enforce a call-by-value
evaluation order; an evaluation context $E$ is an expression with a hole in it
(written $\hole{}$) such that whatever is in the hole is next in line to be
evaluated (if it is not a value already). To fill the hole $\hole$ in an
evaluation context $E$ with the expression $e$, we write $E[e]$.

Figure \ref{fig:opsem-rules} defines a relation $e \step e'$ for expressions $e$
whose outermost structure is immediately $\beta$-reducible; we extend this
relation to all expressions with the rule
\[\infer{e \step e'}{E[e] \step E[e']}\]

%% FIXME
In our rules for $e \step e'$ we make use of a \emph{decidable inequality test
  on values}, $v \ale u : \eq{A}$.
