\section{Introduction}

The phrase ``declarative programming'' is as popular as it is
ambiguous, with seemingly hundreds of disparate senses in which it is
used. However, two of those usages stand out for popularity: both
\emph{functional programming} and \emph{logic programming} are
commonly called declarative languages.

The fact that logic programming languages and functional languages
have largely evolved separately (with a few honorable exceptions such
as Curry~\cite{curry}) can be seen as either an occasion for sorrow,
or it can be seen as an opportunity: as functional language
designers, we can look at logic languages to discover new ideas to
steal.

A Prolog program can be understood as a collection of logical axioms
formulated as Horn clauses (i.e., first-order formulas of the form
$\forall \vec{x}.\;P_1(\vec{x}) \land \ldots \land P_n(\vec{x}) \to
Q(\vec{x})$, where $P_i$ and $Q$ are
atomic formulas).  Execution of a Prolog program can be understood as
running a proof search algorithm on these clauses to figure out
whether a particular formula is derivable or not.

In other words, functional and logic programming languages embody the
Curry-Howard correspondence in two different ways. In a functional
language, types are propositions, terms are proofs, and program
evaluation corresponds to proof normalization. On the other hand, for
logic programming languages, \emph{terms} are propositions, and
program evaluation corresponds to \emph{proof search}.

Due to the undecidability of general theorem proving, designers of
logic programming languages have to both be very careful about the
kinds of formulas they admit as programs, and to be careful about the
proof search algorithm they implement. Prolog offers a very expressive
language --- full Horn clauses --- and so it faces an undecidable
proof search problem. So to make its operational behaviour
predictable, its designers specified a particular proof search
strategy, namely depth-first goal-directed search. As a result,
programmers can reliably reason about the behaviour of a Prolog
program, at the cost of making certain logically natural programs go
into infinite loops. (Notoriously, transitive closure calculations are
much less elegant to program in Prolog than one might naively hope,
since they are naturally computed using a breadth-first proof search
strategy.)

However, this view of Prolog suggests that there are other possible
design choices, such as restricting the logical language sufficiently
to make the proof search problem decidable. Indeed, one of the most
successful evolutions of logic programming in the last decade has been
Datalog~\cite{datalog}, which has taken precisely this tack. Datalog
can be understood as a subset of Prolog carefully designed so as to
ensure the decidability of the proof search problem.

\todo{Be more specific about the restrictions}

\todo{Say something about sub-Turing languages being more optimizable}

As a result of this decidability, the implementors of Datalog have the
freedom to tailor their proof search strategy to the program, and so
Datalog programs can both be extremely concise (and ``declarative'')
and extremely efficient. For example, \citet{whaley-lam} implemented
pointer analysis algorithms in Datalog, and found that they could
reduce the size of their analyses from thousands of lines of code to
\emph{tens} of lines of code, while still retaining competitive
performance.

Obviously, not all 











\paragraph{Contributions}
\begin{itemize}
\item We describe Datafun, a typed language capturing the expressive power of
  Datalog and extending it to support higher-order functional programming.
  Datafun's key feature is to \emph{track monotonicity with types}.

\item We present examples illustrating the expressive power of Datafun,
  including relational-algebra-style operations, transitive closure, CYK
  parsing, and dataflow analysis.

\item We identify the semantic structures underpinning Datalog, and use this to
  give a denotational semantics for Datafun in terms of a pair of adjunctions
  between \cSet{}, \cPoset{}, \cSL{}.

\item We have a prototype implementation of Datafun in Racket. \todo{(CITE)}
\end{itemize}

%% Contributions (as summarized by Michael):
% - Datafun, like Datalog but functional
% - examples, incl. both datalog examples & things datalog canâ€™t do
% - key ingredient is monotonicity; ``found'' semantics by analyzing
%   datalog: two adjunctions, three categories
% - prototype implementation

%% Contributions (as written by Neel):

% - We describe Datafun, a type theory for a language capturing the expressive
%   power of Datalog and extends it to both relax the constructor term
%   restriction and to support higher-order functional programming.

% - We give a variety of examples that illustrate the expressive power of
%   Datafun, such as CYK parsing, dataflow analysis, and transitive closure on
%   graphs, etc. Many of these examples are traditional examples of Datalog,
%   but we are also able to support things like first-class relations (eg,
%   generic transitive closure) and higher-order functions (example using
%   monotonicity and HO?). (doing a fix-point code analysis / parsing something
%   & dispatching on result?)

% - We identify the semantic structures underpinning Datalog, and use this to
%   give a denotational semantics for Datafun in terms of a pair of adjunctions
%   between Set, Poset, and the category of semilattices with finitary joins.

% - We have a prototype implementation of Datafun in Racket.

% Local Variables:
% TeX-master: "datafun"
% End:
