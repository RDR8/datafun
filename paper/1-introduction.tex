\section{Introduction}

The phrase ``declarative programming'' is as popular as it is
ambiguous, with seemingly hundreds of disparate senses in which it is
used. However, two of those usages stand out for popularity: both
\emph{functional programming} and \emph{logic programming} are
commonly called declarative languages.

The fact that logic programming languages and functional languages
have largely evolved separately (with a few honorable exceptions such
as Curry~\cite{curry}) can be seen as either an occasion for sorrow,
or it can be seen as an opportunity: as functional language
designers, we can look at logic languages to discover new ideas to
steal.

A Prolog program can be understood as a collection of logical axioms
formulated as Horn clauses (i.e., first-order formulas of the form
$\forall \vec{x}.\;P_1(\vec{x}) \land \ldots \land P_n(\vec{x}) \to
Q(\vec{x})$, where $P_i$ and $Q$ are
atomic formulas).  Execution of a Prolog program can be understood as
running a proof search algorithm on these clauses to figure out
whether a particular formula is derivable or not.

In other words, functional and logic programming languages embody the
Curry-Howard correspondence in two different ways. In a functional
language, types are propositions, terms are proofs, and program
evaluation corresponds to proof normalization. On the other hand, for
logic programming languages, \emph{terms} are propositions, and
program evaluation corresponds to \emph{proof search}.

Since proof search is in general undecidable, designers of logic
programming languages must be careful both about the kinds of formulas
they admit as programs, and about the proof search algorithm they
implement. Prolog offers a very expressive language --- full Horn
clauses --- and so faces an undecidable proof search problem.
Therefore, Prolog specifies its proof search strategy: depth-first
goal-directed search. This lets Prolog programmers reason about the
behaviour of their programs; however, it also means many logically
natural programs fail to terminate. Notoriously, transitive closure
calculations are much less elegant to program in Prolog than one might
na\"ively hope, since they are naturally computed using a
breadth-first proof search strategy.

\todo{Don't we mean ``a bottom-up/forward-chaining proof search
  strategy''? Does breadth-first backward-chaining search work for
  transitive closure?}

This view of Prolog suggests considering other possible design
choices, such as restricting the logical language so as to make proof
search decidable. Indeed, one of the most successful evolutions of
logic programming in the last decade has been Datalog~\cite{datalog},
which takes precisely this tack. Datalog can be understood as a subset
of Prolog carefully chosen to ensure the decidability of the proof
search problem.

\todo{Isn't Datalog older than ``the last decade''?}

\todo{Be more specific about the restrictions}

\todo{Say something about sub-Turing languages being more optimizable}

Thanks to this decidability, Datalog implementations are free to
tailor their proof search strategy to the program being executed.
Consequently Datalog programs can be both concise and efficient. For
example, \citet{whaley-lam} implemented pointer analysis algorithms in
Datalog, and found that they could reduce their analyses from
\emph{thousands} to \emph{tens} of lines of code while retaining
competitive performance.

Obviously, not all 











\paragraph{Contributions}
\begin{itemize}
\item We describe Datafun, a typed language capturing the expressive power of
  Datalog and extending it to support higher-order functional programming.
  Datafun's key feature is to \emph{track monotonicity with types}.

\item We present examples illustrating the expressive power of Datafun,
  including relational-algebra-style operations, transitive closure, CYK
  parsing, and dataflow analysis.

\item We identify the semantic structures underpinning Datalog, and use this to
  give a denotational semantics for Datafun in terms of a pair of adjunctions
  between \cSet{}, \cPoset{}, \cSL{}.

\item We have a prototype implementation of Datafun in Racket. \todo{(CITE)}
\end{itemize}

%% Contributions (as summarized by Michael):
% - Datafun, like Datalog but functional
% - examples, incl. both datalog examples & things datalog canâ€™t do
% - key ingredient is monotonicity; ``found'' semantics by analyzing
%   datalog: two adjunctions, three categories
% - prototype implementation

%% Contributions (as written by Neel):

% - We describe Datafun, a type theory for a language capturing the expressive
%   power of Datalog and extends it to both relax the constructor term
%   restriction and to support higher-order functional programming.

% - We give a variety of examples that illustrate the expressive power of
%   Datafun, such as CYK parsing, dataflow analysis, and transitive closure on
%   graphs, etc. Many of these examples are traditional examples of Datalog,
%   but we are also able to support things like first-class relations (eg,
%   generic transitive closure) and higher-order functions (example using
%   monotonicity and HO?). (doing a fix-point code analysis / parsing something
%   & dispatching on result?)

% - We identify the semantic structures underpinning Datalog, and use this to
%   give a denotational semantics for Datafun in terms of a pair of adjunctions
%   between Set, Poset, and the category of semilattices with finitary joins.

% - We have a prototype implementation of Datafun in Racket.

% Local Variables:
% TeX-master: "datafun"
% End:
